{"version":3,"sources":["../src/../config-wrap-start-default.js","../src/../../../../../../../module-insertRequire.js","../src/htmlCanvas.js","../src/widget-extensions.js","../src/router/url.js","../src/router/abstractSegment.js","../src/router/parameterSegment.js","../src/router/optionalParameterSegment.js","../src/router/staticSegment.js","../src/router/routeFactory.js","../src/events.js","../src/router/routeMatchResult.js","../src/router/route.js","../src/router/hashLocation.js","../src/router/router.js","../src/router.js","../src/widget.js","../src/widgetjs.js"],"names":["root","factory","define","amd","widgetjs","$","klassified","this","requirejs","require","undef","hasProp","obj","prop","hasOwn","call","normalize","name","baseName","nameParts","nameSegment","mapValue","foundMap","lastIndex","foundI","foundStarMap","starI","i","j","part","baseParts","split","map","config","starMap","charAt","slice","length","nodeIdCompat","jsSuffixRegExp","test","replace","concat","splice","join","indexOf","substring","makeRequire","relName","forceSync","req","apply","aps","arguments","makeNormalize","makeLoad","depName","value","defined","callDep","waiting","args","defining","main","Error","splitPrefix","prefix","index","makeConfig","makeMap","handlers","Object","prototype","hasOwnProperty","plugin","parts","f","n","pr","p","exports","e","module","id","uri","deps","callback","cjsModule","ret","usingExports","callbackType","load","undefined","alt","setTimeout","cfg","_defined","jQuery","HtmlCanvasConstructor","rootElement","htmlTagBrush","element","htmlCanvas","TagBrushConstructor","spec","tag","createElement","getElement","children","append","tags","attributes","omitSymbol","events","tagName","tagBrush","appendBrush","forEach","Array","omit","render","raw","htmlString","renderNonBreaking","elementCache","document","cloneNode","object","appendToBrush","attr","brush","String","appendString","Function","appendFunction","Number","toString","appendChild","child","canHaveChildren","text","innerHTML","aTagBrush","string","createTextNode","fn","createDocumentFragment","asJQuery","get","html","htmlContents","on","eventType","bind","setAttribute","key","attributeName","css","className","addClass","removeClass","parseSegments","path","urlSeparator","filter","Boolean","parsePath","rawUrl","parseQuery","pair","result","exec","query","each","url","subclass","that","my","segments","initialize","super","getPath","getQuery","getSegments","matchRoute","route","matchUrl","build","queryPart","decodeURIComponent","param","abstractSegment","segmentString","options","match","urlSegment","getValue","isParameter","isOptional","class","parameterValidator","constraint","RegExp","exp","option","toLowerCase","val","parameterSegment","substr","constraints","validators","getName","validate","every","validator","optionalParameterSegment","defaultValue","defaults","staticSegment","routeFactory","pattern","routePatternSeparator","trim","segmentFactory","allSubclasses","segment","event","console","warn","register","eventBinding","isBound","unbind","unregister","anEvent","execute","params","isForCallback","cb","bindCallback","binding","bindings","push","onceOn","registerOnce","onceBinding","remove","off","trigger","dispose","eventCategory","ensureEventHolderFor","hasEventNamed","addEvent","namedEvents","createEvent","eventManager","categories","at","eventhandler","routeMatchResult","mergeParameters","routeParameters","queryParameters","allValues","parameterName","queryParameterName","urlParameters","parameters","values","getRoute","getUrl","isMatch","getRouteParameters","getQueryParameters","getParameters","getActionArguments","actionArguments","keys","routeNoMatchResult","instance","orderedSubsets","input","mask","results","total","Math","pow","unshift","urlSegments","sequence","ignoreTrailingSegments","routeSegment","findMatch","sequenceIndex","optionalSequences","ensureOptionalSequences","optionalPositions","optionalSequence","optionalIndex","numRemoved","createMatchResult","parameterValues","matchedIndex","matched","onMatched","expand","hasParameter","some","noHashChangeSupport","window","getWindowHash","location","hash","setWindowHash","aHash","urlToHash","aUrl","urlFromHash","setCurrentHash","newHash","currentHash","history","changed","check","windowHash","pollTimerId","onChanged","setUrl","linkToUrl","back","fallbackUrl","isHistoryEmpty","pop","start","stop","setInterval","clearInterval","hashLocation","hashSingleton","merge","objects","target","locationHandler","routeTable","lastMatch","defaultParameters","resolveUrl","routeMatched","onRouteMatched","routeNotFound","onRouteNotFound","onResolveUrl","addRoute","routeSpec","newRoute","action","fallThrough","priority","findRoute","predicate","numRoutes","routeIndex","getRouteByName","routeName","removeRoute","clear","pipeRoute","router","aRoute","pipeNotFound","aRawUrl","linkTo","includeCurrentParameters","excludeCurrentParameters","linkToPath","redirectTo","redirectToPath","redirectToUrl","redirectToLocationPath","href","startsWith","templateRoute","suppliedParameters","currentParameters","allParameters","linkToParameters","setParameters","getParameter","setDefaultParameter","aFallbackUrl","currentUrl","numMatched","candidateRoute","routerSingleton","getRouter","setRouter","newRouter","widgetExtensions","inRenderingLoop","currentWidget","withCurrentWidget","widget","current","set","idGenerator","newId","renderBasicOn","withChildrenRegistration","renderOn","inUpdateTransaction","initializeSubwidgets","postInitialize","onAttach","onDetach","getId","willDetach","appendTo","aJQuery","withAttachHooks","canvas","empty","isRendered","triggerWillAttach","willAttach","triggerDidAttach","didAttach","inRendering","createEvents","nextId","renderRootOn","renderContentOn","parent","registerChild","subclassResponsibility","willUpdate","update","withinTransaction","onDone","withUpdate","withNoUpdate","extProperty","ext"],"mappings":"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","file":"widgetjs.min.js","sourcesContent":["(function(root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define(\"widgetjs\", [\"jquery\", \"klassified\"], factory);\n    } else {\n        root.widgetjs = factory(root.$, root.klassified);\n    }\n}(this, function($, klassified) {\n/**\n * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                name = name.split('/');\n                lastIndex = name.length - 1;\n\n                // Node .js allowance:\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                }\n\n                name = baseParts.concat(name);\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\n    define('jquery', function() { return $; })\n    define('klassified', function() { return klassified; })\n","\nrequire([\"widgetjs\"]);\n","define('htmlCanvas',[\n\t\"jquery\"\n], function() {\n\n\t/**\n\t * @typedef {function} renderer\n\t * @param {htmlCanvas} html\n\t */\n\n\t/** @typedef {({}|string|renderer|widget|htmlTagBrush|*)} renderable */\n\n\t\t// Supported HTML 'tags'\n\tvar tags = (\"a abbr acronym address area article aside audio b bdi bdo big \" +\n\t\t\"blockquote body br button canvas caption cite code col colgroup command \" +\n\t\t\"datalist dd del details dfn div dl dt em embed fieldset figcaption figure \" +\n\t\t\"footer form frame frameset h1 h2 h3 h4 h5 h6 hr head header hgroup html i \" +\n\t\t\"iframe img input ins kbd keygen label legend li link map mark meta meter \" +\n\t\t\"nav noscript object ol optgroup option output p param pre progress q rp rt\" +\n\t\t\"ruby samp script section select small source span strong style sub summary\" +\n\t\t\"sup table tbody td textarea tfoot th thead time title tr track tt ul var\" +\n\t\t\"video wbr\").split(\" \");\n\n\t// Supported HTML attributes\n\tvar attributes = \"href for id media rel src style title type\".split(\" \");\n\n\tvar omitSymbol = {};\n\n\t// Supported HTML events\n\tvar events = (\"blur focus focusin focusout load resize scroll unload \" +\n\t\"click dblclick mousedown mouseup mousemove mouseover \" +\n\t\"mouseout mouseenter mouseleave change input select submit \" +\n\t\"keydown keypress keyup error dragstart dragenter dragover dragleave drop dragend\").split(\" \");\n\n\tfunction HtmlCanvasConstructor(rootElement) {\n\t\t/**\n\t\t * The root object that brushes will append elements to.\n\t\t *\n\t\t * @type {htmlTagBrush}\n\t\t */\n\t\tthis.root = htmlTagBrush({ element: rootElement });\n\t}\n\n\t/**\n\t * Creates a brush that \"paints\" a tag of type tagName. Any children supplied\n\t * will be appended as children to brush.\n\t *\n\t * @param {string} tagName Type of element (supported by document.createElement)\n\t * @param {renderable[]} [children] Renderable objects to append as children of brush.\n\t */\n\tHtmlCanvasConstructor.prototype.tag = function(tagName, children) {\n\t\tvar tagBrush = htmlTagBrush({ tag: tagName, children: children });\n\t\tthis.root.appendBrush(tagBrush);\n\t\treturn tagBrush;\n\t};\n\n\t/**\n\t * Tags builders for each supported tag type.\n\t *\n\t * @example\n\t *    html.h1(\"Title\");\n\t *    html.strong(\"Important stuff\");\n\t *    html.span(html.strong(userName), \" signed in.\")\n\t */\n\ttags.forEach(function(tagName) {\n\t\tHtmlCanvasConstructor.prototype[tagName] = function() {\n\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\treturn this.tag(tagName, args);\n\t\t};\n\t});\n\n\t/**\n\t * Returns omit symbol that is used to omit a attribute pair\n\t * and omit the object appended to brush.\n\t *\n\t * @returns {{}}\n\t */\n\tHtmlCanvasConstructor.prototype.omit = function() {\n\t\treturn omitSymbol;\n\t};\n\n\t/**\n\t * Append an object to the root brush\n\t *\n\t * @param anObject\n\t */\n\tHtmlCanvasConstructor.prototype.render = function() {\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\tthis.root.render(args);\n\t};\n\n\t/**\n\t * Append an unescaped HTML string to the root brush\n\t */\n\tHtmlCanvasConstructor.prototype.raw = function(htmlString) {\n\t\tthis.root.raw(htmlString);\n\t};\n\n\t/**\n\t * Append an unescaped string replacing all spaces by\n\t * non-breaking spaces\n\t */\n\tHtmlCanvasConstructor.prototype.renderNonBreaking = function(htmlString) {\n\t\tthis.raw(htmlString.replace(/\\s/g, \"&nbsp;\"));\n\t};\n\n\t/**\n\t * htmlCanvas provides a DSL that we use to add elements to the DOM using a HTML looking syntax.\n\t *\n\t * The basic metaphor used is one of painting on a canvas using brushes. The canvas is the\n\t * DOM and the brushes HTML \"tags\". Note that it have nothing to do with the HTML5 canvas tag\n\t *\n\t * @example\n\t *        // A htmlCanvas is created on a jQuery object:\n\t *        var html = htmlCanvas($(\"BODY\"));\n\t *\n\t *        // We write HTML using standard tags:\n\t *        html.h1(\"Hello World!\");\n\t *\n\t *        // and standard attributes:\n\t *        html.a({ id: \"id\", href: \"http://www.google.se\"}, \"Google\");\n\t *\n\t *        // Callbacks can be attached to events:\n\t *        html.a({click: function() { alert(\"Hello World!\")} \"Click me!\");\n\t *\n\t *\t\t// Tags can be nested:\n\t *\t\thtml.div({\"class\" : \"outer_div\"},\n\t *\t\t\thtml.div({\"class\" : \"inner_div\"},\n\t *\t\t\t\thtml.span(\"Some text\")\n\t *\t\t\t)\n\t *\t\t);\n\t *\n\t *\t\t// Parts can be assigned to variables:\n\t *\t\tvar homeButton = html.a(\"Home\").href(\"/\");\n\t *\t\tif(showAlert) {\n\t *\t\t\thomeButton.click(function() { alert(\"Hello\"); });\n\t *\t\t}\n\t *\n\t *\n\t * @param {string|jQuery|htmlTagBrush} [rootElement] Element to \"paint\" on. If not supplied a document fragment will be created\n\t *\n\t * @returns {htmlCanvas}\n\t */\n\tfunction htmlCanvas(rootElement) {\n\t\t/** @typedef {{}} htmlCanvas */\n\t\treturn new HtmlCanvasConstructor(rootElement);\n\t}\n\n\tfunction TagBrushConstructor(spec) {\n\t\t/**\n\t\t * Create a new element from tagName or get it from elements.\n\t\t *\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.element = spec.tag ? this.createElement(spec.tag) : this.getElement(spec.element);\n\t\tif (!this.element) {\n\t\t\tthrow new Error(\"htmlTagBrush requires an element\");\n\t\t}\n\n\t\t/**\n\t\t * Append children to support nesting\n\t\t *\n\t\t * @example\n\t\t *\t\thtml.ul(html.li(html.a({href: \"#\"}, \"home\"));\n\t\t */\n\t\tif (spec.children) {\n\t\t\tthis.append(spec.children);\n\t\t}\n\t}\n\n\tvar elementCache = {};\n\n\t/**\n\t * Creates a new element from tagName\n\t *\n\t * @param {string} tagName\n\t * @returns {Element}\n\t */\n\tTagBrushConstructor.prototype.createElement = function(tagName) {\n\t\tif (!elementCache[tagName]) {\n\t\t\telementCache[tagName] = document.createElement(tagName);\n\t\t}\n\t\treturn elementCache[tagName].cloneNode(false);\n\t};\n\n\t/**\n\t * Appends object as child to brush. A tag brush knows how to append:\n\t *\n\t * - strings\n\t * - functions (that take a htmlCanvas as argument)\n\t * - other brushes and widgets (that implements `appendToBrush()`)\n\t * - map / object literal with attributes (eg. {id: \"aId\", \"class\" : \"aClass\"})\n\t * - array of valid objects (see above)\n\t *\n\t * all other objects are appended using:\n\t * `jQuery(element).append(object);`\n\t *\n\t * @param {renderable|renderable[]|{}} object\n\t */\n\tTagBrushConstructor.prototype.append = function(object) {\n\t\tif (object.appendToBrush) {\n\t\t\tobject.appendToBrush(this);\n\t\t\treturn;\n\t\t}\n\n\t\t// Assume attributes\n\t\tif (typeof object === \"object\") {\n\t\t\tthis.attr(object);\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error(\"Unsupported data type\");\n\t};\n\n\tomitSymbol.appendToBrush = function(brush) {};\n\n\tString.prototype.appendToBrush = function(brush) {\n\t\tbrush.appendString(this);\n\t};\n\n\tFunction.prototype.appendToBrush = function(brush) {\n\t\tbrush.appendFunction(this);\n\t};\n\n\tNumber.prototype.appendToBrush = function(brush) {\n\t\tthis.toString().appendToBrush(brush);\n\t};\n\n\tArray.prototype.appendToBrush = function(brush) {\n\t\tvar length = this.length;\n\t\tfor (var i = length - 1; i >= 0; i--) {\n\t\t\tbrush.append(this[length - i - 1]);\n\t\t}\n\t};\n\n\t/**\n\t * Appends DOM node as last child of element or concatenate with\n\t * text if element can\"t have children.\n\t *\n\t * @param {string|HTMLElement} child\n\t */\n\tTagBrushConstructor.prototype.appendChild = function(child) {\n\t\tif (this.element.canHaveChildren !== false) {\n\t\t\tthis.element.appendChild(child);\n\t\t} else {\n\t\t\tthis.element.text = this.element.text + child.innerHTML;\n\t\t}\n\t};\n\n\t/**\n\t * Appends element of brush\n\t *\n\t * @param {htmlTagBrush} aTagBrush\n\t */\n\tTagBrushConstructor.prototype.appendBrush = function(aTagBrush) {\n\t\tthis.appendChild(aTagBrush.element);\n\t};\n\n\t/**\n\t * Append text as child. `string` is escaped\n\t *\n\t * @param {string} string\n\t */\n\tTagBrushConstructor.prototype.appendString = function(string) {\n\t\tjQuery(this.element).append(document.createTextNode(string));\n\t};\n\n\t/**\n\t * Append function by executing function with this element as canvas.\n\t *\n\t * @param {renderer} fn\n\t */\n\tTagBrushConstructor.prototype.appendFunction = function(fn) {\n\t\tfn(new HtmlCanvasConstructor(this));\n\t};\n\n\t/**\n\t * Element is set to first match if a jQuery was given.\n\t *\n\t * @param {string|jQuery|HTMLElement|widget|htmlTagBrush} [object]\n\t * @returns {HTMLElement}\n\t */\n\tTagBrushConstructor.prototype.getElement = function(object) {\n\n\t\t// Create a fragment if no object\n\t\tif (object === undefined || object === null) {\n\t\t\treturn document.createDocumentFragment();\n\t\t}\n\n\t\t// Any object that implements asJQuery eg. widget and tagBrush\n\t\tif (typeof object === \"object\" && object.asJQuery) {\n\t\t\treturn object.asJQuery().get(0);\n\t\t}\n\n\t\t// Fall back on jQuery if a string containing a selector expression,\n\t\t// a DOM Element, an existing jQuery object or any other argument that\n\t\t// jQuery accept (http://api.jquery.com/jQuery/)\n\t\treturn jQuery(object).get(0);\n\t};\n\n\t/**\n\t * Appends child objects to brush. Can take a single or several arguments.\n\t *\n\t * @example\n\t *\thtml.h1().render(\n\t *\t\t\"hello\",\n\t *\t\thtml.span(\"world\",\n\t *\t\t\tfunction(html) {\n\t *\t\t\t\thtml.img().src(\"foo.img\");\n\t *\t\t\t\t}\n\t *\t\t\t)\n\t *\t\t);\n\t *\n\t * @param {renderable[]} arguments Any renderable objects\n\t * @returns {htmlTagBrush}\n\t */\n\tTagBrushConstructor.prototype.render = function() {\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tthis.append(args[i]);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Implementation for `appendToBrush()` to allow a brush to be\n\t * appended to another brush.\n\t *\n\t * @param {htmlTagBrush} aTagBrush\n\t */\n\tTagBrushConstructor.prototype.appendToBrush = function(aTagBrush) {\n\t\taTagBrush.appendBrush(this);\n\t};\n\n\t/**\n\t * Set unescaped html contents.\n\t *\n\t * @param {string} htmlContents\n\t */\n\tTagBrushConstructor.prototype.html = function(htmlContents) {\n\t\tthis.asJQuery().html(htmlContents);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Append an unescaped html contents.\n\t *\n\t * @param {string} htmlContents\n\t */\n\tTagBrushConstructor.prototype.raw = function(htmlContents) {\n\t\tthis.asJQuery().append(htmlContents);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Append an unescaped string replacing all spaces by\n\t * non-breaking spaces\n\t */\n\tTagBrushConstructor.prototype.renderNonBreaking = function(htmlString) {\n\t\tthis.raw(htmlString.replace(/\\s/g, \"&nbsp;\"));\n\t};\n\n\t/**\n\t * Bind callback to DOM event\n\t *\n\t * @usage\n\t *\t\thtml.a(\"click me\").on(\"click\", function() {\n\t *\t\t\talert(\"click\");\n\t *\t\t});\n\t *\n\t * @param {string} eventType One or more DOM event types, such as \"click\" or \"submit,\" or custom event names.\n\t * @param {function} callback A function to execute each time the event is triggered.\n\t * @returns {{}}\n\t */\n\tTagBrushConstructor.prototype.on = function(eventType, callback) {\n\t\tthis.asJQuery().bind(eventType, callback);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Event functions for each supported event type.\n\t *\n\t * @example\n\t *\taBrush.click(function() { .. });\n\t *\taBrush.blur(function() { .. });\n\t */\n\tevents.forEach(function(eventType) {\n\t\tTagBrushConstructor.prototype[eventType] = function(callback) {\n\t\t\treturn this.on(eventType, callback);\n\t\t};\n\t});\n\n\t/**\n\t * Adds a new attribute or changes the value of an existing attribute on the specified element.\n\t * @param key\n\t * @param value\n\t * @returns {{}}\n\t */\n\tTagBrushConstructor.prototype.setAttribute = function(key, value) {\n\t\t// Omit attribute if value is omit\n\t\tif (value === omitSymbol) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis.element.setAttribute(key, value);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Accessors for each supported attribute.\n\t *\n\t * @example\n\t *\taBrush.id(\"id\");\n\t *\taBrush.src(\"javascript:0\");\n\t *\taBrush.href(\"#\");\n\t */\n\tattributes.forEach(function(attributeName) {\n\t\tTagBrushConstructor.prototype[attributeName] = function(value) {\n\t\t\treturn this.setAttribute(attributeName, value);\n\t\t};\n\t});\n\n\t/**\n\t * Set element style with key/value or object literal.\n\t *\n\t * @example\n\t *\t\thtml.h1().css(\"display\", \"block\");\n\t *\t\thtml.h1().css({\"display\" : \"block\", \"color\" : \"red\"});\n\t *\n\t * @param {string|{}} key\n\t * @param {string} value\n\t * @returns {{}}\n\t */\n\tTagBrushConstructor.prototype.css = function(key, value) {\n\t\tif (typeof key === \"string\") {\n\t\t\tthis.asJQuery().css(key, value);\n\t\t}\n\t\telse {\n\t\t\tthis.asJQuery().css(key); // otherwise assume key is a map (object literal)\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Set attributes using object literal.\n\t *\n\t * @example\n\t *\thtml.h1().attr({id : \"myid\", \"class\" : \"myclass\"});\n\t *\n\t * @note\n\t *\tUse klass or \"class\" with quotation marks as key instead of class since its a reserved word.\n\t *\n\t * @param object\n\t * @returns {{}}\n\t */\n\tTagBrushConstructor.prototype.attr = function(object) {\n\t\tfor (var key in object) {\n\t\t\tif (object.hasOwnProperty(key)) {\n\t\t\t\t// Attach functions\n\t\t\t\tif (typeof object[key] === \"function\") {\n\t\t\t\t\tthis.on(key, object[key]);\n\t\t\t\t}\n\n\t\t\t\telse if (key === \"klass\") {\n\t\t\t\t\tthis.element.className = object[key];\n\t\t\t\t} else {\n\t\t\t\t\tthis.setAttribute(key, object[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Appends className to class attribute\n\t * @param className\n\t * @returns {htmlTagBrush}\n\t */\n\tTagBrushConstructor.prototype.addClass = function(className) {\n\t\tthis.asJQuery().addClass(className);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Removes className from class attribute\n\t *\n\t * @param {string} className\n\t * @returns {htmlTagBrush}\n\t */\n\tTagBrushConstructor.prototype.removeClass = function(className) {\n\t\tthis.asJQuery().removeClass(className);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns jQuery that match element.\n\t * @returns {jQuery}\n\t */\n\tTagBrushConstructor.prototype.asJQuery = function() {\n\t\treturn jQuery(this.element);\n\t};\n\n\t/**\n\t * A tag brush object represents a DOM element, built on a canvas. The element can\n\t * be created from a \"tag\" or an element matched using \"jQuery\".\n\t *\n\t * Note: A brush is usually only created from `htmlCanvas` and it should only\n\t * be used once.\n\t *\n\t * @param {{}} spec\n\t * @param {string} [spec.tag] Name of tag to create (using document.createElement)\n\t * @param {string|jQuery|widget|htmlTagBrush|*} [spec.element]\n\t * @param {renderable[]} [spec.children]\n\t *\n\t * @returns {htmlTagBrush}\n\t */\n\tfunction htmlTagBrush(spec) {\n\n\t\t/** @typedef {{}} htmlTagBrush */\n\t\treturn new TagBrushConstructor(spec);\n\t}\n\n\treturn htmlCanvas;\n});\n\n","// Widget extensions\n//\n// In your application include widget extensions. Using require.js:\n// define([\"canvas/\"widget-extensions], function(ext) { ... });\n//\n// add properties to ext that you need in all widgets.\n// ext.hello = function() { alert(\"hello world\")};\n//\n// and use in all widgets:\n// my.hello();\n\ndefine('widget-extensions',[], function() {\n\treturn {};\n});\n\n","define('router/url',[\n\t\"klassified\"\n], function(klassified) {\n\n\t/**\n\t * Token/Char used to separate segments in URL paths.\n\t * @type {string}\n\t */\n\tvar urlSeparator = \"/\";\n\n\t/**\n\t * A `url` actually represents the fragment part of the actual url.\n\t *\n\t * @example\n\t *    var url = url({rawUrl: \"path/to?foo=a&bar=b\"});\n\t *    url.getPath(); // => \"path/to\"\n\t *    url.getQuery(); // => {foo: \"a\", bar: \"b\"}\n\t *    url.matchRoute(aRoute); // => true\n\t *\n\t * @param {string} rawUrl\n\t * @returns {url}\n\t */\n\tvar url = klassified.object.subclass(function(that, my) {\n\n\t\tvar rawUrl;\n\t\tvar path;\n\t\tvar query;\n\t\tvar segments;\n\n\t\tmy.initialize = function(spec) {\n\t\t\tmy.super(spec);\n\t\t\trawUrl = spec.rawUrl || \"\";\n\t\t\tpath = parsePath(rawUrl);\n\t\t\tquery = parseQuery(rawUrl);\n\t\t\tsegments = parseSegments(path);\n\t\t};\n\n\t\t//\n\t\t// Public\n\t\t//\n\n\t\t/**\n\t\t * URL path\n\t\t * @returns {string}\n\t\t */\n\t\tthat.getPath = function() { return path; };\n\n\t\t/**\n\t\t * Key/Value pairs parsed from query\n\t\t *\n\t\t * @returns {{}}\n\t\t */\n\t\tthat.getQuery = function() { return query; };\n\n\t\t/**\n\t\t * Segments in path parsed by splitting `path` by `urlSeparator`\n\t\t *\n\t\t * @returns {string[]}\n\t\t */\n\t\tthat.getSegments = function() { return segments; };\n\n\t\t/**\n\t\t * Answers true if the route is a match for the receiver\n\t\t *\n\t\t * @param route\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.matchRoute = function(route) {\n\t\t\treturn route.matchUrl(that);\n\t\t};\n\n\t\t/**\n\t\t * Returns `rawUrl`\n\t\t * @returns {string}\n\t\t */\n\t\tthat.toString = function() {\n\t\t\treturn rawUrl;\n\t\t};\n\t});\n\n\t/**\n\t * Create URL from path and query\n\t *\n\t * @example\n\t *    var aUrl = url(\"/path/to\", {foo: \"bar\" });\n\t *    aUrl.toString(); // => \"path/to?foo=bar\"\n\t *\n\t * @param {string} path\n\t * @param {{}} query\n\t * @returns {url}\n\t */\n\turl.build = function(path, query) {\n\t\tif (typeof(path) === \"undefined\" || path === null || typeof path !== \"string\") {\n\t\t\tthrow \"accepts only string paths\";\n\t\t}\n\n\t\tif (query) {\n\t\t\tvar queryPart = decodeURIComponent(jQuery.param(query));\n\t\t\tif (queryPart) {\n\t\t\t\treturn url({rawUrl: path + \"?\" + queryPart});\n\t\t\t}\n\t\t}\n\n\t\treturn url({rawUrl: path});\n\t};\n\n\t/**\n\t * Splits URL path into segments. Removes leading, trailing, and\n\t * duplicated `urlSeparator`.\n\t *\n\t * @example\n\t *    parseSegments(\"/a/path/to\"); // => [\"a\", \"path\", \"to\"]\n\t *\n\t * @param path\n\t * @returns {string[]}\n\t */\n\tfunction parseSegments(path) {\n\t\t// Split on separator and remove all leading, trailing, and\n\t\t// duplicated `urlSeparator` by filtering empty strings.\n\t\treturn path.split(urlSeparator).filter(Boolean);\n\t}\n\n\t/**\n\t * Returns path from a raw URL\n\t *\n\t * @example\n\t *    parsePath(\"/a/path/to?foo=bar\"); // => \"/a/path/to\"\n\t *\n\t * @param {string} rawUrl\n\t * @returns {string}\n\t */\n\tfunction parsePath(rawUrl) {\n\t\treturn rawUrl.replace(/\\?.*$/g, \"\");\n\t}\n\n\t/**\n\t * Extract query key/value(s) from a rawUrl and return them as an\n\t * object literal with key/values.\n\t *\n\t * @example\n\t *    parsePath(\"/a/path/to?foo=bar&test=1\"); // => {foo: \"bar\", test: \"1\"}\n\t *\n\t * @param {string} rawUrl\n\t * @returns {{}}\n\t */\n\tfunction parseQuery(rawUrl) {\n\t\t// Extract query key/value(s) from a rawUrl and add them to `query` object.\n\t\tvar result = /[^?]*\\?(.*)$/g.exec(rawUrl);\n\t\tvar query = {};\n\t\tvar pair;\n\t\tif (result && result.length >= 2) {\n\t\t\t(result[1].split(\"&\")).forEach(function(each) {\n\t\t\t\tpair = each.split(\"=\");\n\t\t\t\tquery[pair[0]] = pair[1];\n\t\t\t});\n\t\t}\n\n\t\treturn query;\n\t}\n\n\treturn url;\n});\n\n","define('router/abstractSegment',[\n\t\"klassified\"\n], function(klassified) {\n\t/**\n\t * A segment represents a single part of a route that can be matched\n\t * against a URL segment using `match()`.\n\t *\n\t * @param {{}} spec\n\t * @param {string} segmentString\n\t * @param {{}} spec.options all route options\n\t * @param my\n\t * @returns {abstractSegment}\n\t */\n\tvar abstractSegment = klassified.object.subclass(function(that, my) {\n\n\t\tmy.initialize = function(spec) {\n\t\t\tmy.super(spec);\n\t\t\tmy.segmentString = spec.segmentString;\n\t\t\tmy.options = spec.options || {};\n\t\t};\n\n\t\t//\n\t\t// Public\n\t\t//\n\n\t\t/**\n\t\t * Answers true if route segment match URL segment\n\t\t *\n\t\t * @param {string} urlSegment\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.match = function(urlSegment) {\n\t\t\treturn false;\n\t\t};\n\n\t\t/**\n\t\t * Value captured for urlSegment\n\t\t *\n\t\t * @param {string} urlSegment\n\t\t * @returns {*}\n\t\t */\n\t\tthat.getValue = function(urlSegment) {\n\t\t\treturn my.segmentString;\n\t\t};\n\n\t\t/**\n\t\t * Variable part of the route.\n\t\t *\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.isParameter = function() {\n\t\t\treturn false;\n\t\t};\n\n\t\t/**\n\t\t * Optional segments can be omitted in URLs and the\n\t\t * URL will still match the route if all other non\n\t\t * optional segments match.\n\t\t *\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.isOptional = function() {\n\t\t\treturn false;\n\t\t};\n\n\t\t/**\n\t\t * String representation for segment that can be used eg. when debugging.\n\t\t * @returns {*}\n\t\t */\n\t\tthat.toString = function() {\n\t\t\treturn my.segmentString;\n\t\t};\n\t});\n\n\tabstractSegment.class(function(that) {\n\t\tthat.match = function(segmentString) {\n\t\t\treturn false;\n\t\t};\n\t});\n\n\treturn abstractSegment;\n});\n\n","define('router/parameterSegment',[\n\t\"./abstractSegment\"\n], function(abstractSegment) {\n\n\t/**\n\t * Constructs validator functions from constraints parameters.\n\t *\n\t * @param {*} constraint\n\t * @returns {function} function that take a urlSegment as argument\n\t */\n\tfunction parameterValidator(constraint) {\n\t\t// Custom function that take a url segment as argument\n\t\tif (typeof constraint === \"function\") {\n\t\t\treturn constraint;\n\t\t}\n\n\t\t// Match against RegExp\n\t\tif (constraint instanceof RegExp) {\n\t\t\tvar exp = new RegExp(constraint);\n\t\t\treturn function(urlSegment) {\n\t\t\t\treturn exp.test(urlSegment);\n\t\t\t};\n\t\t}\n\n\t\t// Match valid options in an array\n\t\tif (Object.prototype.toString.call(constraint) === \"[object Array]\") {\n\t\t\tvar options = constraint.map(function(option) {\n\t\t\t\treturn option.toLowerCase();\n\t\t\t});\n\t\t\treturn function(urlSegment) {\n\t\t\t\tvar val = urlSegment.toLowerCase();\n\t\t\t\treturn options.indexOf(val) !== -1;\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Parameter match URL segments if all constraints are met.\n\t *\n\t * @param {{}} spec abstractSegment spec\n\t * @param [my]\n\t * @returns {parameterSegment}\n\t */\n\tvar parameterSegment = abstractSegment.subclass(function(that, my) {\n\n\t\tmy.initialize = function(spec) {\n\t\t\tmy.super(spec);\n\t\t\tmy.name = my.segmentString.substr(1); // strip of the leading #\n\t\t\tmy.constraints = (my.options.constraints && my.options.constraints[my.name] &&\n\t\t\t\t[my.options.constraints[my.name]]) || [];\n\t\t\tmy.validators = my.constraints.map(parameterValidator).filter(Boolean);\n\t\t};\n\n\t\t//\n\t\t// Public\n\t\t//\n\n\t\t/**\n\t\t * Name is segmentString without leading property type char.\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tthat.getName = function() {\n\t\t\treturn my.name;\n\t\t};\n\n\t\t/**\n\t\t * Value captured for urlSegment\n\t\t *\n\t\t * @param {string} urlSegment\n\t\t * @returns {*}\n\t\t */\n\t\tthat.getValue = function(urlSegment) {\n\t\t\treturn urlSegment;\n\t\t};\n\n\t\t/**\n\t\t * Always true\n\t\t *\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.isParameter = function() {\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Match urSegment if all constraints are met.\n\t\t *\n\t\t * @param {string} urlSegment\n\t\t * @returns {boolean|*}\n\t\t */\n\t\tthat.match = function(urlSegment) {\n\t\t\treturn urlSegment !== undefined && that.validate(urlSegment);\n\t\t};\n\n\t\t/**\n\t\t * Answers true if url segment meet all constraints for parameter.\n\t\t *\n\t\t * @param {string} urlSegment\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.validate = function(urlSegment) {\n\t\t\treturn my.validators.every(function(validator) {\n\t\t\t\treturn validator(urlSegment);\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * String representation for segment that can be used eg. when debugging.\n\t\t * @returns {*}\n\t\t */\n\t\tthat.toString = function() {\n\t\t\treturn \"param(\" + that.getName() + \")\";\n\t\t};\n\t});\n\n\tparameterSegment.class(function(that) {\n\n\t\t/**\n\t\t * Match segment strings with a leading `#`.\n\t\t * @param {string} segmentString\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.match = function(segmentString) {\n\t\t\treturn segmentString.substr(0, 1) === \"#\";\n\t\t};\n\t});\n\n\treturn parameterSegment;\n});\n\n","define('router/optionalParameterSegment',[\n\t\"./parameterSegment\"\n], function(parameterSegment) {\n\n\t/**\n\t * Optional parameters can have a default value.\n\t *\n\t * @param {{}} spec abstractSegment string\n\t * @param my\n\t * @returns {parameter}\n\t */\n\tvar optionalParameterSegment = parameterSegment.subclass(function(that, my) {\n\n\t\tmy.initialize = function(spec) {\n\t\t\tmy.super(spec);\n\t\t\tmy.defaultValue = my.options.defaults && my.options.defaults[my.name];\n\t\t};\n\n\t\t//\n\t\t// Public\n\t\t//\n\n\t\t/**\n\t\t * Parameter value or default value if not matched.\n\t\t *\n\t\t * @param {string} urlSegment\n\t\t * @returns {*}\n\t\t */\n\t\tthat.getValue = function(urlSegment) {\n\t\t\treturn urlSegment === undefined ?\n\t\t\t\tmy.defaultValue :\n\t\t\t\turlSegment;\n\t\t};\n\n\t\t/**\n\t\t * Always true.\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.isOptional = function() {\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * String representation for segment that can be used eg. when debugging.\n\t\t * @returns {*}\n\t\t */\n\t\tthat.toString = function() {\n\t\t\treturn \"optional(\" + that.getName() + \")\";\n\t\t};\n\t});\n\n\toptionalParameterSegment.class(function(that) {\n\t\t/**\n\t\t * Match segment strings with a leading `?`.\n\t\t * @param {string} segmentString\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.match = function(segmentString) {\n\t\t\treturn segmentString.substr(0, 1) === \"?\";\n\t\t};\n\t});\n\n\treturn optionalParameterSegment;\n});\n\n","define('router/staticSegment',[\n\t\"./abstractSegment\"\n], function(abstractSegment) {\n\n\t/**\n\t * A static segment match URL segments that are identical\n\t * to the route segment string.\n\t *\n\t * @param spec abstractSegment spec\n\t * @param [my]\n\t * @returns {segment}\n\t */\n\tvar staticSegment = abstractSegment.subclass(function(that, my) {\n\n\t\t/**\n\t\t * Static segment match if URL and route segment\n\t\t * strings are identical.\n\t\t *\n\t\t * @param {string} urlSegment\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.match = function(urlSegment) {\n\t\t\treturn that.getValue() === urlSegment;\n\t\t};\n\n\t\treturn that;\n\t});\n\n\tstaticSegment.class(function(that) {\n\n\t\t/**\n\t\t * Match all but parameter segment strings\n\t\t * @param {string} segmentString\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.match = function(segmentString) {\n\t\t\treturn [\"#\", \"?\"].indexOf(segmentString[0]) === -1;\n\t\t};\n\t});\n\n\treturn staticSegment;\n});\n\n","define('router/routeFactory',[\n\t\"./abstractSegment\",\n\t\"./parameterSegment\",\n\t\"./optionalParameterSegment\",\n\t\"./staticSegment\"\n], function(abstractSegment) {\n\n\t/**\n\t * Token/Char used to separate segments in route patterns.\n\t * @type {string}\n\t */\n\tvar routePatternSeparator = \"/\";\n\n\t/**\n\t * Creates a route from pattern. A pattern is a string with route segments\n\t * separated by `routePatternSeparator`.\n\t *\n\t * @example\n\t *    routeFactory(`/foo/#bar/?baz`);\n\t *\n\t * @param {string} pattern\n\t * @param {{}} options\n\t * @returns {abstractSegment[]}\n\t */\n\tfunction routeFactory(pattern, options) {\n\t\tif (!pattern) {\n\t\t\treturn [];\n\t\t}\n\n\t\toptions = options || {};\n\t\tvar segmentStrings = pattern.split(routePatternSeparator);\n\n\t\tvar nonEmptySegmentStrings = segmentStrings\n\t\t\t.map(Function.prototype.call, String.prototype.trim)\n\t\t\t.filter(Boolean);\n\n\t\tvar segmentArray = nonEmptySegmentStrings.map(function(segmentString) {\n\t\t\treturn segmentFactory(segmentString, options);\n\t\t});\n\n\t\treturn segmentArray;\n\t}\n\n\t/**\n\t * Create segment from string\n\t *\n\t * @param {string} segmentString\n\t * @param {{}} options\n\t * @returns {abstractSegment}\n\t */\n\tfunction segmentFactory(segmentString, options) {\n\t\toptions = options || {};\n\n\t\tvar segments = abstractSegment.allSubclasses();\n\n\t\t// Find segment type from string\n\t\tfor (var i = 0; i < segments.length; i++) {\n\t\t\tvar segment = segments[i];\n\t\t\tif (segment.match(segmentString)) {\n\t\t\t\treturn segment({\n\t\t\t\t\tsegmentString: segmentString,\n\t\t\t\t\toptions: options\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\treturn routeFactory;\n});\n\n","define('events',[], function() {\n\n\t/**\n\t * Keeps a list of bindings/callbacks that can be added using **push()** and\n\t * removed using **remove()**. *trigger()* executes all callbacks one by one in registration order.\n\t *\n\t * @param [spec] {Object}\n\t * @param [my] {Object}\n\t * @returns {event}\n\t */\n\tfunction event(spec, my) {\n\t\tmy = my || {};\n\n\t\t// DEPRECATED: use that.register() instead.\n\t\tfunction that(callback) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn(\"Using an event as a function is deprecated. Send register() to the event instead.\");\n\t\t\treturn that.register(callback);\n\t\t}\n\n\t\tvar bindings = [];\n\n\t\t// #### Public API\n\n\t\t/**\n\t\t * Binds callback to event. The callback will be invoked whenever the event is fired.\n\t\t *\n\t\t * @deprecated use that.register() instead.\n\t\t * @param callback {function}\n\t\t * @returns {eventBinding}\n\t\t */\n\t\tthat.on = function(callback) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn(\"Sending on() to an event is deprecated. Send register() instead.\");\n\t\t\treturn that.register(callback);\n\t\t};\n\n\t\t/**\n\t\t * Binds callback to event. The callback will be invoked\n\t\t * whenever the event is fired. Avoid adding the same callback\n\t\t * twice.\n\t\t *\n\t\t * @param callback {function}\n\t\t * @returns {eventBinding}\n\t\t */\n\t\tthat.register = function(callback) {\n\t\t\treturn bindCallback(callback);\n\t\t};\n\n\t\t/**\n\t\t * Binds a callback to an event\n\t\t *\n\t\t * @param spec.callback {function} Callback to execute on event\n\t\t * @param spec.event {event} Event to bind callback to\n\n\t\t * @returns {eventBinding}\n\t\t */\n\t\tfunction eventBinding(spec) {\n\t\t\tspec = spec || {};\n\t\t\tvar that = {};\n\n\t\t\tvar callback = spec.callback;\n\t\t\tvar event = spec.event;\n\n\t\t\t/**\n\t\t\t * Is bound to an event\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tthat.isBound = function() {\n\t\t\t\treturn event !== undefined;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Remove itself from event, if bound.\n\t\t\t */\n\t\t\tthat.unbind = function() {\n\t\t\t\tif (that.isBound()) {\n\t\t\t\t\tevent.unregister(that);\n\t\t\t\t\tevent = undefined;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * @param anEvent\n\t\t\t */\n\t\t\tthat.bind = function(anEvent) {\n\t\t\t\tthat.unbind();\n\t\t\t\tif (anEvent) {\n\t\t\t\t\tevent = anEvent;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Executes connected callback\n\t\t\t * @param params\n\t\t\t */\n\t\t\tthat.execute = function(params) {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback.apply(that, params);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Returns true if and only if the receiver is triggering\n\t\t\t * the callback given as parameter.\n\t\t\t *\n\t\t\t * @param cb {function} callback to test against\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tthat.isForCallback = function(cb) {\n\t\t\t\treturn callback === cb;\n\t\t\t};\n\n\t\t\treturn that;\n\t\t}\n\n\t\t/**\n\t\t * Like on() except callback will only be fired once\n\t\t *\n\t\t * @deprecated use registerOnce() instead\n\t\t * @param callback {function}\n\t\t * @returns {eventBinding}\n\t\t */\n\t\tthat.onceOn = function(callback) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn(\"Sending onceOn() to an event is deprecated. Send registerOnce() instead.\");\n\t\t\treturn that.registerOnce(callback);\n\t\t};\n\n\t\t/**\n\t\t * Like on() except callback will only be fired once\n\t\t *\n\t\t * @param callback {function}\n\t\t * @returns {eventBinding}\n\t\t */\n\t\tthat.registerOnce = function(callback) {\n\t\t\tvar onceBinding = eventBinding({\n\t\t\t\tcallback: function() {\n\t\t\t\t\tmy.remove(onceBinding);\n\t\t\t\t\tcallback.apply(that, arguments);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tbindings.push(onceBinding);\n\t\t\treturn onceBinding;\n\t\t};\n\n\t\t/**\n\t\t * Removed \"binding\" attached to event.\n\t\t * @deprecated use unregister() instead\n\t\t * @param name {String} Name of event\n\t\t * @param binding {eventBinding} Binding\n\t\t */\n\t\tthat.off = function(binding) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn(\"Sending off() to an event is deprecated. Send unregister() instead.\");\n\t\t\tthat.unregister(binding);\n\t\t};\n\n\t\t/**\n\t\t * Removed \"binding\" attached to event.\n\t\t * @param name {String} Name of event\n\t\t * @param binding {eventBinding} Binding\n\t\t */\n\t\tthat.unregister = function(binding) {\n\t\t\tmy.remove(binding);\n\t\t};\n\n\t\t/**\n\t\t * Trigger event by executing all callbacks one by one in registration order.\n\t\t *\n\t\t * @param arguments {Object|Object[]} Arguments passed to callback of each binding\n\t\t */\n\t\tthat.trigger = function() {\n\t\t\tvar params = Array.prototype.slice.call(arguments);\n\t\t\tbindings.forEach(function(binding) {\n\t\t\t\tbinding.execute(params);\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Unbind all callbacks bound to this event.\n\t\t */\n\t\tthat.dispose = function() {\n\t\t\tbindings.slice().forEach(function(binding) {\n\t\t\t\tbinding.unbind();\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * @param binding {eventBinding}\n\t\t */\n\t\tmy.push = function(binding) {\n\t\t\tbindings.push(binding);\n\t\t\tbinding.bind(that);\n\t\t};\n\n\t\t/**\n\t\t * @param binding {eventBinding}\n\t\t */\n\t\tmy.remove = function(binding) {\n\t\t\tbindings.splice(bindings.indexOf(binding), 1);\n\t\t};\n\n\t\t/**\n\t\t * Create and add callback binding to the receiver. Avoid\n\t\t * adding the same callback twice.\n\t\t *\n\t\t * @param callback\n\t\t * @returns {eventBinding}\n\t\t */\n\t\tfunction bindCallback(callback) {\n\t\t\tvar binding = bindings.filter(function(binding) {\n\t\t\t\treturn binding.isForCallback(callback);\n\t\t\t})[0];\n\n\t\t\t// Don't register the same callback twice:\n\t\t\tif (binding) {\n\t\t\t\treturn binding;\n\t\t\t}\n\n\t\t\tbinding = eventBinding({callback: callback, event: that});\n\t\t\tbindings.push(binding);\n\n\t\t\treturn binding;\n\t\t}\n\n\t\treturn that;\n\t}\n\n\t/**\n\t * Keeps a list of events.\n\t *\n\t * @returns {{}}\n\t */\n\tfunction eventCategory() {\n\t\tvar that = {};\n\n\t\t// Map of events with name as key\n\t\tvar namedEvents = {};\n\t\tvar events = [];\n\n\t\t/**\n\t\t * Lazily makes sure that an event exists for \"name\".\n\t\t *\n\t\t * @param name {String}\n\t\t * @returns {event} Also return the event\n\t\t */\n\t\tfunction ensureEventHolderFor(name) {\n\t\t\tif (!hasEventNamed(name)) {\n\t\t\t\taddEvent(event(), name);\n\t\t\t}\n\t\t\treturn namedEvents[name];\n\t\t}\n\n\t\t/**\n\t\t * Create a new event and if name i supplied adds it to event manager\n\t\t *\n\t\t * @param [name] {string} Name of event in eventHandler\n\t\t * @returns {event}\n\t\t */\n\t\tthat.createEvent = function(name) {\n\t\t\treturn addEvent(event(), name);\n\t\t};\n\n\t\t/**\n\t\t * Binds callback to a named event. The callback will be invoked whenever the event is fired.\n\t\t *\n\t\t * @deprecated use register() instead\n\t\t * @param name {String}\n\t\t * @param callback {function}\n\t\t */\n\t\tthat.on = function(name, callback) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn(\"Sending on() to a category is deprecated. Send register() instead.\");\n\t\t\treturn that.register(name, callback);\n\t\t};\n\n\t\t/**\n\t\t * Binds callback to a named event. The callback will be invoked whenever the event is fired.\n\t\t *\n\t\t * @param name {String}\n\t\t * @param callback {function}\n\t\t */\n\t\tthat.register = function(name, callback) {\n\t\t\treturn ensureEventHolderFor(name).register(callback);\n\t\t};\n\n\t\t/**\n\t\t * Removed \"binding\" attached to event.\n\t\t * @deprecated use unregister() instead\n\t\t * @param name {String} Name of event\n\t\t * @param binding {eventBinding} Binding\n\t\t */\n\t\tthat.off = function(name, binding) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn(\"Sending off() to a category is deprecated. Send unregister() instead.\");\n\t\t\treturn that.unregister(name, binding);\n\t\t};\n\n\t\t/**\n\t\t * Removed \"binding\" attached to event.\n\t\t * @param name {String} Name of event\n\t\t * @param binding {eventBinding} Binding\n\t\t */\n\t\tthat.unregister = function(name, binding) {\n\t\t\treturn ensureEventHolderFor(name).unregister(binding);\n\t\t};\n\n\t\t/**\n\t\t * Like on() except callback will only be fired once\n\t\t *\n\t\t * @deprecated use registerOnce() instead\n\t\t * @param name\n\t\t * @param callback\n\t\t * @returns {*}\n\t\t */\n\t\tthat.onceOn = function(name, callback) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn(\"Sending onceOn() to a category is deprecated. Send registerOnce() instead.\");\n\t\t\treturn that.registerOnce(name, callback);\n\t\t};\n\n\t\t/**\n\t\t * Like on() except callback will only be fired once\n\t\t *\n\t\t * @param name\n\t\t * @param callback\n\t\t * @returns {*}\n\t\t */\n\t\tthat.registerOnce = function(name, callback) {\n\t\t\treturn ensureEventHolderFor(name).registerOnce(callback);\n\t\t};\n\n\t\t/**\n\t\t * Trigger all callbacks attached to event\n\t\t * @param name\n\t\t * @param arguments Any arguments to trigger is sent as arguments to callback.\n\t\t */\n\t\tthat.trigger = function(name) {\n\t\t\tvar params = Array.prototype.slice.call(arguments, 1);\n\t\t\tvar event = ensureEventHolderFor(name);\n\t\t\tevent.trigger.apply(that, params);\n\t\t};\n\n\t\t/**\n\t\t * Dispose all events.\n\t\t */\n\t\tthat.dispose = function() {\n\t\t\tevents.forEach(function(event) {\n\t\t\t\tevent.dispose();\n\t\t\t});\n\n\t\t\tnamedEvents = {};\n\t\t\tevents = [];\n\t\t};\n\n\t\t/**\n\t\t * Answers true if an event with name exists\n\t\t *\n\t\t * @param name {String}\n\t\t * @returns {boolean}\n\t\t */\n\t\tfunction hasEventNamed(name) {\n\t\t\treturn namedEvents[name] !== undefined;\n\t\t}\n\n\t\t/**\n\t\t * @param event {event}\n\t\t * @param [name] {string}\n\t\t * @returns {event}\n\t\t */\n\t\tfunction addEvent(event, name) {\n\t\t\tevents.push(event);\n\t\t\tif (name) {\n\t\t\t\tnamedEvents[name] = event;\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\n\t\treturn that;\n\t}\n\n\t/**\n\t * Singleton object that keeps a list of named event categories.\n\t */\n\tvar eventManager = (function() {\n\t\tvar that = {};\n\n\t\t// Map of event categories with (category) name as key\n\t\tvar categories = {};\n\n\t\t/**\n\t\t * Register a new event category with \"name\".\n\t\t * @param name\n\t\t * @returns {eventCategory}\n\t\t */\n\t\tthat.register = function(name) {\n\t\t\tif (categories[name]) {\n\t\t\t\tthrow (\"A event category is already registered for \" + name);\n\t\t\t}\n\t\t\tcategories[name] = eventCategory();\n\n\t\t\treturn categories[name];\n\t\t};\n\n\t\t/**\n\t\t * Returns event category by name. Creates a new category if not already\n\t\t * registered.\n\t\t * @param name\n\t\t * @returns {*}\n\t\t */\n\t\tthat.at = function(name) {\n\t\t\tif (!categories[name]) {\n\t\t\t\tthat.register(name);\n\t\t\t}\n\n\t\t\treturn categories[name];\n\t\t};\n\n\t\treturn that;\n\t})();\n\n\t// Exports Singleton event manager\n\t// but also expose event and event category\n\n\teventManager.eventCategory = eventCategory;\n\t//@deprecated Spelling mistake\n\teventManager.eventhandler = eventCategory;\n\teventManager.event = event;\n\n\treturn eventManager;\n});\n\n","define('router/routeMatchResult',[\n\t\"klassified\"\n], function(klassified) {\n\n\t/**\n\t * Route match result are used as the answer of matching a url against a route.\n\t *\n\t * @param {{}} [spec]\n\t * @param {{}} spec.url Matched URL\n\t * @param {{}} spec.route Matched Route\n\t * @param {{}} spec.values Hash with matched parameter names as keys and matching url segment values.\n\t *\n\t * @returns {routeMatchResult}\n\t */\n\tvar routeMatchResult = klassified.object.subclass(function(that, my) {\n\n\t\tvar url;\n\t\tvar route;\n\t\tvar urlParameters;\n\t\tvar routeParameters;\n\t\tvar parameters;\n\n\t\tmy.initialize = function(spec) {\n\t\t\tmy.super(spec);\n\t\t\turl = spec.url;\n\t\t\troute = spec.route;\n\n\t\t\turlParameters = (url && url.getQuery && url.getQuery()) || {};\n\t\t\trouteParameters = spec.values || {};\n\t\t\tparameters = mergeParameters(routeParameters, urlParameters);\n\t\t};\n\n\t\t//\n\t\t// Public\n\t\t//\n\n\t\t/**\n\t\t * Matched route\n\t\t *\n\t\t * @returns {route}\n\t\t */\n\t\tthat.getRoute = function() {\n\t\t\treturn route;\n\t\t};\n\n\t\t/**\n\t\t * Matched URL\n\t\t *\n\t\t * @returns {url}\n\t\t */\n\t\tthat.getUrl = function() {\n\t\t\treturn url;\n\t\t};\n\n\t\t/**\n\t\t * Answers true if route match URL\n\t\t *\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.isMatch = function() {\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Values for parameters in route\n\t\t *\n\t\t * @returns {{}}\n\t\t */\n\t\tthat.getRouteParameters = function() {\n\t\t\treturn routeParameters;\n\t\t};\n\n\t\t/**\n\t\t * Values for parameters in query\n\t\t *\n\t\t * @returns {{}}\n\t\t */\n\t\tthat.getQueryParameters = function() {\n\t\t\treturn url.getQuery();\n\t\t};\n\n\t\t/**\n\t\t * All matched parameters\n\t\t *\n\t\t * @returns {{}}\n\t\t */\n\t\tthat.getParameters = function() {\n\t\t\treturn parameters;\n\t\t};\n\n\t\t/**\n\t\t * Constructs an array with all parameters in same order as in route pattern with\n\t\t * query parameter as the last value.\n\t\t *\n\t\t * @returns {Array}\n\t\t */\n\t\tthat.getActionArguments = function() {\n\t\t\tvar actionArguments = Object.keys(routeParameters).map(function(parameterName) {\n\t\t\t\treturn routeParameters[parameterName];\n\t\t\t});\n\t\t\tactionArguments.push(url.getQuery());\n\t\t\treturn actionArguments;\n\t\t};\n\n\t\t//\n\t\t// Private\n\t\t//\n\n\t\tfunction mergeParameters(routeParameters, queryParameters) {\n\t\t\tvar allValues = {};\n\n\t\t\t// Fill with route parameters\n\t\t\tfor (var parameterName in routeParameters) {\n\t\t\t\tif (routeParameters.hasOwnProperty(parameterName)) {\n\t\t\t\t\tallValues[parameterName] = routeParameters[parameterName];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fill with query parameters\n\t\t\tfor (var queryParameterName in queryParameters) {\n\t\t\t\tif (queryParameters.hasOwnProperty(queryParameterName)) {\n\t\t\t\t\tallValues[queryParameterName] = queryParameters[queryParameterName];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn allValues;\n\n\t\t}\n\t});\n\n\trouteMatchResult.class(function(that) {\n\n\t\t/**\n\t\t * Result to use when match does not match url\n\t\t */\n\t\tthat.routeNoMatchResult = (function() {\n\n\t\t\t/** @typedef {routeMatchResult} routeNoMatchResult */\n\t\t\tvar instance = that();\n\n\t\t\tinstance.isMatch = function() {\n\t\t\t\treturn false;\n\t\t\t};\n\n\t\t\treturn instance;\n\t\t})();\n\t});\n\n\treturn routeMatchResult;\n});\n\n","define('router/route',[\n\t\"./routeFactory\",\n\t\"events\",\n\t\"./routeMatchResult\",\n\t\"./url\",\n\t\"klassified\",\n\t\"jquery\"\n], function(routeFactory, events, routeMatchResult, url, klassified) {\n\n\t/**\n\t * Routes represent the path for which an action should be taken (see `matched` event).\n\t *\n\t * Route is implemented as an array of segments. A route can be constructed from a segment array\n\t * or a route pattern string.\n\t *\n\t * @example\n\t *        var aRouteFromSegments = route({segments: arrayOfRouteSegments});\n\t *        var aRouteFromPattern = route(\"/segmentA/#aParameter/?andAnOptionalParameter\");\n\t *\n\t * Route pattern strings are parsed into segment arrays by `routeFactory`.\n\t *\n\t * Route match URL:s by comparing the URL segments against an array\n\t * of route segments. A route match a URL if the segments matches the route segments.\n\t *\n\t * @example\n\t *    route(\"/User/#id\").matchUrl(\"/User/john\").matched(); // => true\n\t *\n\t * Route would match URL since first segment in URL match Route (both \"User\") and second\n\t * segment is matched since a route parameter will match all values (if no constraints).\n\t *\n\t * Some segments can be optional and other mandatory. The strategy to match route with optional\n\t * segments is to match it against the segments and then all combinations of optional parameters.\n\t *\n\t * An array with all optional sequences is calculated when route is created.\n\t *\n\t * Note: Avoid large number of optionals since it will consume memory and slow down matching.\n\t * You can use query parameters instead.\n\t *\n\t * When a URL is matched the router will bind matches parameters to corresponding segments in URL\n\t * and return them in `matchResult`\n\t *\n\t * @example\n\t *\n\t *        var result = route(\"/user/#id\").matchUrl(\"/user/john\");\n\t *        console.dir(result.getValues()); // => { user: \"john\"}\n\t *\n\t * Routes can also be used as patterns for creating URLs\n\t *\n\t *        var url = route(\"/user/#id\").expand({id: \"john\"});\n\t *        console.log(url); // => \"/user/john\"\n\t *\n\t *\n\t * @param {string|{}} spec Route pattern or route spec\n\t * @param {boolean} spec.ignoreTrailingSegments Route will match if all route segment match\n\t * even if url have trailing unmatched segments\n\t * @param {segment[]} [spec.segments] Array of route segments\n\t *\n\t * @param {{}} my\n\t * @returns {route}\n\t */\n\tvar route = klassified.object.subclass(function(that, my) {\n\n\t\tvar segments;\n\t\tvar ignoreTrailingSegments;\n\t\tvar optionalSequences;\n\n\t\tmy.initialize = function(spec) {\n\t\t\tmy.super();\n\t\t\t// Build segments from pattern\n\t\t\tsegments = routeFactory(spec.pattern, spec.options);\n\n\t\t\t// Route match URL if all route segments match\n\t\t\t// but URL still contain trailing segments (default false)\n\t\t\tignoreTrailingSegments = (spec.options && spec.options.ignoreTrailingSegments) || false;\n\n\t\t\t// Array with all optional sequences, ie. all combinations\n\t\t\t// of optional parameters. Array must be ordered to match URL:s\n\t\t\t// left to right.\n\t\t\toptionalSequences = [];\n\n\t\t\t// Pre-calculate optional sequences.\n\t\t\tensureOptionalSequences();\n\t\t};\n\n\t\tmy.events = events.eventCategory();\n\n\t\t//\n\t\t// Public\n\t\t//\n\n\t\tthat.matched = my.events.createEvent(\"matched\");\n\t\tthat.onMatched = that.matched; // deprecated\n\n\t\t// @deprecated Use event property instead\n\t\tthat.on = my.events.register;\n\n\t\t/**\n\t\t * Match route against URL by comparing segments. Triggers\n\t\t * `matched` event on match.\n\t\t *\n\t\t * @param {url} url\n\t\t * @returns {routeMatchResult}\n\t\t */\n\t\tthat.matchUrl = function(url) {\n\t\t\tvar match = findMatch(url);\n\t\t\tif (!match) {\n\t\t\t\treturn routeMatchResult.routeNoMatchResult;\n\t\t\t}\n\n\t\t\tvar result = createMatchResult(match, url);\n\t\t\tmy.events.trigger(\"matched\", result);\n\n\t\t\treturn result;\n\t\t};\n\n\t\t/**\n\t\t * Expands route into a url. All non optional route parameters must exist\n\t\t * in `params`.\n\t\t *\n\t\t * @param {{}} params Key/Values where keys are route parameter names and values the values to use\n\t\t *\n\t\t * @returns {string} URL string\n\t\t */\n\t\tthat.expand = function(params) {\n\t\t\tparams = params || {};\n\n\t\t\t// Try to expand route into URL\n\t\t\tvar urlSegments = [];\n\t\t\tsegments.forEach(function(routeSegment) {\n\t\t\t\tvar urlSegment;\n\t\t\t\tif (routeSegment.isParameter()) {\n\t\t\t\t\t// Use supplied value for parameters\n\t\t\t\t\turlSegment = params[routeSegment.getName()];\n\t\t\t\t} else {\n\t\t\t\t\t// name/value for segments\n\t\t\t\t\turlSegment = routeSegment.getValue();\n\t\t\t\t}\n\n\t\t\t\t// Skip if no match and optional\n\t\t\t\tif (urlSegment === undefined &&\n\t\t\t\t\trouteSegment.isOptional()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Validate segment\n\t\t\t\tif (!routeSegment.match(urlSegment)) {\n\t\t\t\t\tthrow new Error(\"Could not generate a valid URL\");\n\t\t\t\t}\n\n\t\t\t\turlSegments.push(urlSegment);\n\t\t\t});\n\n\t\t\tvar query = {};\n\n\t\t\tObject.keys(params).forEach(function(param) {\n\t\t\t\tif (!that.hasParameter(param)) {\n\t\t\t\t\tquery[param] = params[param];\n\t\t\t\t\t// Handle array param values\n\t\t\t\t\tif (query[param] instanceof Array) {\n\t\t\t\t\t\tquery[param] = query[param].join(\",\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn url.build(urlSegments.join(\"/\"), query).toString();\n\t\t};\n\n\t\t/**\n\t\t * Answers true if parameter with `name` exists in route.\n\t\t *\n\t\t * @param {string} name\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.hasParameter = function(name) {\n\t\t\treturn segments.some(function(segment) {\n\t\t\t\treturn segment.isParameter() && segment.getName() === name;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Returns a string representation of route useful for debugging.\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tthat.toString = function() {\n\t\t\treturn \"route(\" + segments.join(\"/\") + \")\";\n\t\t};\n\n\t\t//\n\t\t// Private\n\t\t//\n\n\t\t/**\n\t\t * Checks if an array of url segments match a sequence of route segments.\n\t\t *\n\t\t * @param {string[]} urlSegments\n\t\t * @param {segments[]} [sequence] Route segments will be used as default\n\t\t * @returns {boolean}\n\t\t */\n\t\tfunction isMatch(urlSegments, sequence) {\n\t\t\tsequence = sequence || segments;\n\n\t\t\t// Can not match if different sizes\n\t\t\tif (urlSegments.length !== sequence.length && !ignoreTrailingSegments) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// All routeSegments much match corresponding URL segment\n\t\t\treturn sequence.every(function(routeSegment, index) {\n\t\t\t\tvar urlSegment = urlSegments[index];\n\t\t\t\treturn urlSegment !== undefined && routeSegment.match(urlSegment);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Returns first sequence of segments that match url or null if no sequence match.\n\t\t *\n\t\t * @param {url} url\n\t\t * @returns {segment[]}\n\t\t */\n\t\tfunction findMatch(url) {\n\t\t\tvar urlSegments = url.getSegments();\n\n\t\t\t// Try match url segments\n\t\t\tif (isMatch(urlSegments)) {\n\t\t\t\treturn segments;\n\t\t\t}\n\n\t\t\t// then optional sequences\n\t\t\tvar sequenceIndex;\n\t\t\tfor (sequenceIndex = 0; sequenceIndex < optionalSequences.length; sequenceIndex++) {\n\t\t\t\tif (isMatch(urlSegments, optionalSequences[sequenceIndex])) {\n\t\t\t\t\treturn optionalSequences[sequenceIndex];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Pre-calculate all optional sequences of segments.\n\t\t */\n\t\tfunction ensureOptionalSequences() {\n\t\t\t// Find positions for optionals\n\t\t\tvar optionalPositions = [];\n\t\t\tsegments.forEach(function(segment, index) {\n\t\t\t\tif (segment.isOptional()) {\n\t\t\t\t\toptionalPositions.push(index);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (optionalPositions.length > 15) {\n\t\t\t\tthrow new Error(\"Too many optional arguments. \\\"\" + optionalPositions.length +\n\t\t\t\t\t\"\\\" optionals would generate  \" + Math.pow(2, optionalPositions.length) +\n\t\t\t\t\t\" optional sequences.\");\n\t\t\t}\n\n\t\t\t// Generate possible sequences\n\t\t\tvar possibleOptionalSequences = orderedSubsets(optionalPositions);\n\n\t\t\tpossibleOptionalSequences.forEach(function(sequence) {\n\t\t\t\t// Clone segments array and remove optionals matching\n\t\t\t\t// indexes in index sequence\n\t\t\t\tvar optionalSequence = segments.slice();\n\t\t\t\tsequence.forEach(function(optionalIndex, numRemoved) {\n\t\t\t\t\t// Remove optional but take in to account that we have already\n\t\t\t\t\t// removed {numRemoved} from permutation.\n\t\t\t\t\toptionalSequence.splice(optionalIndex - numRemoved, 1);\n\t\t\t\t});\n\n\t\t\t\toptionalSequences.push(optionalSequence);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Create a \"routeMatchResult\" from a matched sequence.\n\t\t *\n\t\t * @param {segment[]} match Matched segment sequence\n\t\t * @param {url} url Matched URL\n\t\t *\n\t\t * @returns {routeMatchResult}\n\t\t */\n\t\tfunction createMatchResult(match, url) {\n\t\t\tvar urlSegments = url.getSegments();\n\n\t\t\tvar parameterValues = {};\n\t\t\tsegments.forEach(function(routeSegment) {\n\t\t\t\tif (!routeSegment.isParameter()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar matchedIndex = match.indexOf(routeSegment);\n\t\t\t\tif (matchedIndex >= 0) {\n\t\t\t\t\tparameterValues[routeSegment.getName()] = routeSegment.getValue(urlSegments[matchedIndex]);\n\t\t\t\t} else {\n\t\t\t\t\tparameterValues[routeSegment.getName()] = routeSegment.getValue();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn routeMatchResult({\n\t\t\t\troute: that,\n\t\t\t\turl: url,\n\t\t\t\tvalues: parameterValues\n\t\t\t});\n\t\t}\n\t});\n\n\t/**\n\t * Generates all subsets of an array with same internal order. Returned subsets are\n\t * ordered in right to left order.\n\t *\n\t * @example\n\t *    orderedSubsets([1,2,3]); // => [[1,2,3],[2,3],[1,3],[3],[1,2],[2],[1]]\n\t *\n\t * @param {[]} input\n\t * @returns {[[]]} Array with all subset arrays\n\t */\n\tfunction orderedSubsets(input) {\n\t\tvar results = [];\n\t\tvar result;\n\t\tvar mask;\n\t\tvar total = Math.pow(2, input.length);\n\n\t\tfor (mask = 1; mask < total; mask++) {\n\t\t\tresult = [];\n\t\t\tvar i = input.length - 1;\n\t\t\tdo {\n\t\t\t\tif ((mask & (1 << i)) !== 0) {\n\t\t\t\t\tresult.unshift(input[i]);\n\t\t\t\t}\n\t\t\t} while (i--);\n\t\t\tresults.unshift(result);\n\t\t}\n\n\t\treturn results;\n\t}\n\n\treturn route;\n});\n\n","define('router/hashLocation',[\n\t\"jquery\",\n\t\"events\",\n\t\"./url\",\n\t\"klassified\"\n], function(jQuery, events, url, klassified) {\n\n\t/**\n\t * In modern browsers we use the \"hashchange\" event to listen for location changes. If not supported\n\t * we poll for changes using a timer.\n\t */\n\tvar noHashChangeSupport = !(\"onhashchange\" in window);\n\n\t/**\n\t * Num ms between each location change poll on browsers without \"hashchange\"\n\t */\n\tvar pollInterval = 25;\n\n\t/**\n\t * Manages and listens for changes in the hash fragment of the URL.\n\t *\n\t * @example\n\t *        var location = hash();\n\t *        hash.on(\"changed\", function(newUrl) { window.alert(newUrl); });\n\t *        location.start();\n\t *        location.setUrl(\"newUrl\");\n\t *        location.setUrl(\"anotherUrl\");\n\t *        location.back();\n\t *\n\t * @param {{}} [spec]\n\t *\n\t * @param [my]\n\t * @returns {hashLocation}\n\t */\n\tvar hashLocation = klassified.object.subclass(function(that, my) {\n\n\t\tvar pollTimerId = null;\n\n\t\tmy.currentHash = undefined; // last hash fragment\n\t\tmy.history = []; // history of visited hash fragments\n\t\tmy.events = events.eventCategory();\n\n\t\t//\n\t\t// Public\n\t\t//\n\n\t\t/**\n\t\t * Triggered when location change with new URL as\n\t\t * argument.\n\t\t *\n\t\t * @type {event}\n\t\t */\n\t\tthat.changed = my.events.createEvent(\"changed\");\n\t\tthat.onChanged = that.changed; // deprecated\n\n\t\t/**\n\t\t * Set hash fragment to URL\n\t\t *\n\t\t * @param {url|string} aUrl\n\t\t */\n\t\tthat.setUrl = function(aUrl) {\n\t\t\tvar aHash = urlToHash(aUrl);\n\t\t\tsetWindowHash(aHash);\n\t\t\tsetCurrentHash(aHash);\n\t\t};\n\n\t\t/**\n\t\t * Creates a URL from current hash fragment\n\t\t *\n\t\t * @returns {url}\n\t\t */\n\t\tthat.getUrl = function() {\n\t\t\treturn urlFromHash(getWindowHash());\n\t\t};\n\n\t\t/**\n\t\t * Creates a raw URL string from a URL that can be used eg. in a href.\n\t\t *\n\t\t * @param {string|url} aUrl\n\t\t * @returns {string}\n\t\t */\n\t\tthat.linkToUrl = function(aUrl) {\n\t\t\treturn urlToHash(aUrl);\n\t\t};\n\n\t\t/**\n\t\t * Navigate back to previous location in history. If history is empty\n\t\t * the location will be changed to fallback URL.\n\t\t *\n\t\t * @param {string|url} fallbackUrl\n\t\t * @returns {string} URL\n\t\t */\n\t\tthat.back = function(fallbackUrl) {\n\t\t\tif (!that.isHistoryEmpty()) {\n\t\t\t\tmy.history.pop();\n\t\t\t\tsetWindowHash(my.history.pop());\n\t\t\t} else if (fallbackUrl) {\n\t\t\t\tsetWindowHash(urlToHash(fallbackUrl));\n\t\t\t}\n\n\t\t\tsetCurrentHash();\n\t\t};\n\n\t\t/**\n\t\t * Return `true` if the history is empty.\n\t\t */\n\t\tthat.isHistoryEmpty = function() {\n\t\t\treturn my.history.length <= 1;\n\t\t};\n\n\t\t/**\n\t\t * Start listening for URL changes. If `hashchange` is supported by the browser\n\t\t * it will be used, otherwise a timer will poll for changes.\n\t\t */\n\t\tthat.start = function() {\n\t\t\tthat.stop();\n\n\t\t\tmy.currentHash = getWindowHash();\n\t\t\tmy.history = [my.currentHash];\n\n\t\t\tif (noHashChangeSupport) {\n\t\t\t\tpollTimerId = setInterval(check, pollInterval);\n\t\t\t} else {\n\t\t\t\tjQuery(window).bind(\"hashchange\", check);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Stop listening for location changes and unregister all bindings.\n\t\t */\n\t\tthat.stop = function() {\n\t\t\tif (pollTimerId) {\n\t\t\t\tclearInterval(pollTimerId);\n\t\t\t\tpollTimerId = null;\n\t\t\t}\n\t\t\tjQuery(window).unbind(\"hashchange\", check);\n\t\t};\n\n\t\t//\n\t\t// Private\n\t\t//\n\n\t\tfunction getWindowHash() {\n\t\t\treturn window.location.hash;\n\t\t}\n\n\t\tfunction setWindowHash(aHash) {\n\t\t\twindow.location.hash = aHash;\n\t\t}\n\n\t\tfunction urlToHash(aUrl) {\n\t\t\tif (typeof aUrl === \"string\") {\n\t\t\t\taUrl = url({rawUrl: aUrl});\n\t\t\t}\n\t\t\treturn \"#!/\" + aUrl.toString();\n\t\t}\n\n\t\tfunction urlFromHash(aHash) {\n\t\t\t// Remove hash/hash-bang and any leading /\n\t\t\treturn url({rawUrl: aHash.replace(/^#!?[\\/]?/, \"\")});\n\t\t}\n\n\t\tfunction setCurrentHash(newHash) {\n\t\t\tnewHash = newHash || getWindowHash();\n\n\t\t\tif (my.currentHash !== newHash) {\n\t\t\t\tmy.currentHash = newHash;\n\t\t\t\tmy.history.push(my.currentHash);\n\t\t\t}\n\n\t\t\tthat.changed.trigger(urlFromHash(my.currentHash));\n\t\t}\n\n\t\tfunction check() {\n\t\t\tvar windowHash = getWindowHash();\n\n\t\t\tvar urlChanged = my.currentHash !== windowHash;\n\t\t\tif (urlChanged) {\n\t\t\t\tsetCurrentHash(windowHash);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn hashLocation;\n});\n\n","define('router/router',[\n\t\"events\",\n\t\"./route\",\n\t\"./url\",\n\t\"./hashLocation\",\n\t\"klassified\",\n\t\"jquery\"\n], function(events, route, url, hashLocation, klassified) {\n\n\t/**\n\t * Lazily creates a singleton instance of\n\t * hash-fragment listener `hashLocation()`.\n\t *\n\t * @returns {hashLocation}\n\t */\n\tfunction hashSingleton() {\n\t\tif (!hashSingleton.instance) {\n\t\t\thashSingleton.instance = hashLocation();\n\t\t}\n\n\t\treturn hashSingleton.instance;\n\t}\n\n\t/**\n\t * Router allow you to keep state in the URL. When a user visits a specific URL the application\n\t * can be transformed accordingly.\n\t *\n\t * Router have a routing table consisting of an array of routes. When the router resolves a URL\n\t * each route is matched against the URL one-by-one. The order is defined by the route priority\n\t * property (lower first). If two routes have the same priority or if priority is omitted, routes\n\t * are matched in registration order.\n\t *\n\t * @param [spec]\n\t * @param [spec.locationHandler] hashSingleton by default\n\t *\n\t * @returns {{}}\n\t */\n\tvar router = klassified.object.subclass(function(that, my) {\n\n\t\tmy.initialize = function(spec) {\n\t\t\tmy.super(spec);\n\t\t\tmy.location = spec.locationHandler || hashSingleton();\n\t\t\tmy.routeTable = [];\n\t\t\tmy.lastMatch = undefined;\n\t\t\tmy.defaultParameters = {};\n\n\t\t\t// Listen for URL changes and resolve URL when changed\n\t\t\tmy.location.changed.register(function() { my.resolveUrl(); });\n\t\t};\n\n\t\t// Events\n\t\tmy.events = events.eventCategory();\n\n\t\t//\n\t\t// Public\n\t\t//\n\n\t\t/**\n\t\t * Triggered when a route is matched with `routeMatchResult` as argument.\n\t\t * @type {event}\n\t\t */\n\t\tthat.routeMatched = my.events.createEvent(\"routeMatched\");\n\t\tthat.onRouteMatched = that.routeMatched; // deprecated\n\n\t\t/**\n\t\t * Triggered when a route is not matched with \"url\" as argument.\n\t\t * @type {event}\n\t\t */\n\t\tthat.routeNotFound = my.events.createEvent(\"routeNotFound\");\n\t\tthat.onRouteNotFound = that.routeNotFound; // deprecated\n\n\t\t/**\n\t\t * Triggered each time a URL is resolved with `url` as argument\n\t\t * @type {event}\n\t\t */\n\t\tthat.onResolveUrl = my.events.createEvent(\"resolveUrl\");\n\n\t\t// @deprecated Use event property instead\n\t\tthat.on = my.events.register;\n\n\t\t//\n\t\t// Public\n\t\t//\n\n\t\t/**\n\t\t * Tries to resolve URL by matching the URL against all routes in\n\t\t * route table. Unless `fallThrough` is set on the matched route, router\n\t\t * will stop on first match.\n\t\t *\n\t\t * Last match is also stored as `my.lastMatch`\n\t\t *\n\t\t * @param {url} [aUrl] A URL or current url as default\n\t\t */\n\t\tthat.resolveUrl = function(aUrl) {\n\t\t\tif (typeof aUrl === \"string\") {\n\t\t\t\taUrl = url({rawUrl: aUrl});\n\t\t\t}\n\n\t\t\tmy.resolveUrl(aUrl);\n\t\t};\n\n\t\t/**\n\t\t * Creates and adds a new route to the routing table.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t *        // Simplest possible route\n\t\t *        aRouter.addRoute({\n\t\t\t *\t\t\tpattern: \"/user/#id\",\n\t\t\t *\t\t\taction: function(id, query) { console.log(id, query);},\n\t\t\t *\t\t});\n\t\t *\n\t\t *        // Route with name and priority,\n\t\t *        aRouter.addRoute({\n\t\t\t *\t\t\tname: \"user\",\n\t\t\t *\t\t\tpattern: \"/user/#id\",\n\t\t\t *\t\t\tpriority: 4000,\n\t\t\t *\t\t\taction: function(id) { console.log(id);},\n\t\t\t *\t\t});\n\t\t *\n\t\t *        // Route with only pattern and custom matched event handler,\n\t\t *        var route = aRouter.addRoute({ pattern: \"\"/user/#id\"\"});\n\t\t *        route.matched.register(function(result) {\n\t\t\t *\t\t\tconsole.dir(result.getValues());\n\t\t\t *\t\t});\n\t\t *\n\t\t *        // Route with route options,\n\t\t *        aRouter.addRoute({\n\t\t\t *\t\t\tpattern: \"/user/#id\",\n\t\t\t *\t\t\tpriority: 4000,\n\t\t\t *\t\t\tdefaults: {\n\t\t\t *\t\t\t\tid: \"john_doe\"\n\t\t\t *\t\t\t},\n\t\t\t *\t\t\tconstraints: {\n\t\t\t *\t\t\t\tid: [\"john_doe\", \"jane_doe\"]\n\t\t\t *\t\t\t}\n\t\t\t *\t\t});\n\t\t *\n\t\t *\n\t\t * @param {routeSpec} routeSpec Options passed to route plus options below\n\t\t * @param {string} routeSpec.pattern Route pattern as string\n\t\t * @param {function} routeSpec.action Executed when route is matched with parameters as arguments +\n\t\t * query object as the last argument.\n\t\t * @param {string} routeSpec.pattern Route pattern as string\n\t\t *\n\t\t * @returns {route}\n\t\t */\n\t\tthat.addRoute = function(routeSpec) {\n\t\t\trouteSpec = routeSpec || {};\n\n\t\t\tvar newRoute = route({\n\t\t\t\tpattern: routeSpec.pattern,\n\t\t\t\toptions: routeSpec\n\t\t\t});\n\n\t\t\tif (routeSpec.action) {\n\t\t\t\tnewRoute.matched.register(function(result) {\n\t\t\t\t\trouteSpec.action.apply(this, result.getActionArguments());\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tnewRoute.name = routeSpec.name;\n\t\t\tnewRoute.fallThrough = routeSpec.fallThrough;\n\n\t\t\tnewRoute.priority = routeSpec.priority;\n\t\t\tmy.addRoute(newRoute);\n\n\t\t\treturn newRoute;\n\t\t};\n\n\t\t/**\n\t\t * Find a route using a predicate function. The function is applied on routes\n\t\t * on-by-one until match.\n\t\t *\n\t\t * @param {function} predicate\n\t\t * @returns {route} Matched route or null if not matched\n\t\t */\n\t\tthat.findRoute = function(predicate) {\n\t\t\tvar numRoutes = my.routeTable.length;\n\t\t\tfor (var routeIndex = 0; routeIndex < numRoutes; routeIndex++) {\n\t\t\t\tvar route = my.routeTable[routeIndex];\n\t\t\t\tif (predicate(route)) {\n\t\t\t\t\treturn route;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\t/**\n\t\t * Finds route by name\n\t\t *\n\t\t * @param {string} routeName\n\t\t * @returns {route}\n\t\t */\n\t\tthat.getRouteByName = function(routeName) {\n\t\t\treturn that.findRoute(function(route) {\n\t\t\t\treturn route.name && route.name === routeName;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Removes a route from routing table\n\t\t *\n\t\t * @param route\n\t\t */\n\t\tthat.removeRoute = function(route) {\n\t\t\tvar index = my.routeTable.indexOf(route);\n\t\t\tif (index === -1) {\n\t\t\t\tthrow new Error(\"Route not in route table\");\n\t\t\t}\n\n\t\t\tmy.routeTable.splice(index, 1);\n\t\t};\n\n\t\t/**\n\t\t * Removes all routes from routing table.\n\t\t */\n\t\tthat.clear = function() {\n\t\t\tmy.routeTable = [];\n\t\t\tmy.lastMatch = undefined;\n\t\t};\n\n\t\t/**\n\t\t * Pipes URL matching \"routeSpec\" to another router.\n\t\t *\n\t\t * @param {{}} routeSpec Same options as `addRoute`\n\t\t * @param {router} router\n\t\t *\n\t\t * @returns {route}\n\t\t */\n\t\tthat.pipeRoute = function(routeSpec, router) {\n\t\t\tif (!routeSpec || !routeSpec.pattern) {\n\t\t\t\tthrow new Error(\"Route pattern required\");\n\t\t\t}\n\n\t\t\tvar aRoute = that.addRoute(routeSpec);\n\t\t\taRoute.matched.register(function(result) {\n\t\t\t\trouter.resolveUrl(result.getUrl());\n\t\t\t});\n\n\t\t\treturn aRoute;\n\t\t};\n\n\t\t/**\n\t\t * Pipe not found to a different router\n\t\t *\n\t\t * @param {router} router\n\t\t * @returns {route}\n\t\t */\n\t\tthat.pipeNotFound = function(router) {\n\t\t\treturn that.routeNotFound.register(function(aRawUrl) {\n\t\t\t\trouter.resolveUrl(aRawUrl);\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Returns the current URL\n\t\t * @returns {url}\n\t\t */\n\t\tthat.getUrl = function() {\n\t\t\treturn my.location.getUrl();\n\t\t};\n\n\t\t/**\n\t\t * Constructs a link that can be used eg. in href.\n\t\t *\n\t\t * @example\n\t\t *    // Link to a route by name (recommended)\n\t\t *    aRouter.linkTo(\"users-list\", {user: \"jane\"});\n\t\t *\n\t\t *    // Link to a path\n\t\t *    aRouter.linkTo(\"/user/mikael\");\n\t\t *    aRouter.linkTo(\"/user/\", {sortBy: \"name\"});\n\t\t *\n\t\t * @param {string} routeName Name of route or path\n\t\t * @param {{}} [parameters]\n\t\t * @param {boolean} [includeCurrentParameters=false] Merge parameters with parameters in current match.\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tthat.linkTo = function(routeName, parameters, includeCurrentParameters) {\n\t\t\tvar route = that.getRouteByName(routeName);\n\t\t\tif (route) {\n\t\t\t\treturn my.location.linkToUrl(that.expand({\n\t\t\t\t\trouteName: route.name,\n\t\t\t\t\tparameters: parameters,\n\t\t\t\t\texcludeCurrentParameters: !includeCurrentParameters\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// fallback to path (eg. /user/john) if route is not defined\n\t\t\treturn that.linkToPath(routeName, parameters);\n\t\t};\n\n\t\t/**\n\t\t * Link to a path\n\t\t *\n\t\t * @example\n\t\t *    aRouter.linkToPath(\"/user/mikael\");\n\t\t *    aRouter.linkToPath(\"/user/\", {sortBy: \"name\"});\n\t\t *\n\t\t * @param {string} path\n\t\t * @param {{}} query\n\t\t * @returns {string}\n\t\t */\n\t\tthat.linkToPath = function(path, query) {\n\t\t\treturn that.linkToUrl(url.build(path, query));\n\t\t};\n\n\t\t/**\n\t\t * Link from url\n\t\t *\n\t\t * @param {url} aUrl\n\t\t * @returns {string}\n\t\t */\n\t\tthat.linkToUrl = function(aUrl) {\n\t\t\treturn my.location.linkToUrl(aUrl);\n\t\t};\n\n\t\t/**\n\t\t * Redirects browser to route or path.\n\t\t *\n\t\t * @example\n\t\t *    // Redirect to a route by name\n\t\t *    aRouter.redirectTo(\"users-list\", {user: \"jane\"});\n\t\t *\n\t\t *    // Redirect to a path\n\t\t *    aRouter.redirectTo(\"/user/mikael\");\n\t\t *    aRouter.redirectTo(\"/user/\", {sortBy: \"name\"});\n\t\t *\n\t\t * @param {string} routeName\n\t\t * @param {{}} [parameters]\n\t\t * @param {boolean} [includeCurrentParameters=false] Merge parameters with parameters in current match.\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tthat.redirectTo = function(routeName, parameters, includeCurrentParameters) {\n\t\t\tvar route = that.getRouteByName(routeName);\n\t\t\tif (route) {\n\t\t\t\treturn my.location.setUrl(that.expand({\n\t\t\t\t\trouteName: route.name,\n\t\t\t\t\tparameters: parameters,\n\t\t\t\t\texcludeCurrentParameters: !includeCurrentParameters\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\treturn that.redirectToPath(routeName, parameters);\n\t\t};\n\n\t\t/**\n\t\t * Redirect to a path\n\t\t *\n\t\t * @example\n\t\t *    aRouter.redirectToPath(\"/user/mikael\");\n\t\t *    aRouter.redirectToPath(\"/user/\", {sortBy: \"name\"});\n\t\t *\n\t\t * @param {string} path\n\t\t * @param {{}} query\n\t\t * @returns {string}\n\t\t */\n\t\tthat.redirectToPath = function(path, query) {\n\t\t\treturn that.redirectToUrl(url.build(path, query));\n\t\t};\n\n\t\t/**\n\t\t * Redirect to url\n\t\t *\n\t\t * @param {url} aUrl\n\t\t * @returns {string}\n\t\t */\n\t\tthat.redirectToUrl = function(aUrl) {\n\t\t\treturn my.location.setUrl(aUrl);\n\t\t};\n\n\t\t/**\n\t\t * Redirect to another location (as in window.location) path.\n\t\t *\n\t\t * @param {string} path\n\t\t * @return {undefined}\n\t\t */\n\t\tthat.redirectToLocationPath = function(path) {\n\t\t\twindow.location.href = path.startsWith(\"/\") ? path : \"/\" + path;\n\t\t};\n\n\t\t/**\n\t\t * Constructs a new URL from parameters with a route as template. If no route is\n\t\t * supplied the last matched route is used.\n\t\t *\n\t\t * Parameters are merged with parameters from last match unless `excludeCurrentParameters`\n\t\t * is set to true.\n\t\t *\n\t\t * @param {{}} [options]\n\t\t * @param {string} [options.routeName] Name of route to link to. Default route from last match.\n\t\t * @param {{}} [options.parameters={}]\n\t\t * @param {boolean} [options.excludeCurrentParameters=false]\n\t\t *\n\t\t * @returns {url}\n\t\t */\n\t\tthat.expand = function(options) {\n\t\t\tvar routeName = options.routeName;\n\t\t\tvar suppliedParameters = options.parameters || {};\n\t\t\tvar excludeCurrentParameters = options.excludeCurrentParameters || false;\n\n\t\t\t// Pick a template route\n\t\t\tvar templateRoute;\n\t\t\tif (routeName) {\n\t\t\t\ttemplateRoute = that.getRouteByName(routeName) || route();\n\t\t\t} else if (my.lastMatch) {\n\t\t\t\ttemplateRoute = my.lastMatch.getRoute();\n\t\t\t} else {\n\t\t\t\ttemplateRoute = route();\n\t\t\t}\n\n\t\t\t// Merge current parameters with supplied parameters\n\t\t\tvar currentParameters = !excludeCurrentParameters ? that.getParameters() : {};\n\t\t\tvar allParameters = merge(currentParameters, suppliedParameters);\n\n\t\t\t// Fill with defaults if needed\n\t\t\tObject.keys(my.defaultParameters).forEach(function(parameterName) {\n\t\t\t\tif (!(parameterName in allParameters)) {\n\t\t\t\t\tallParameters[parameterName] = typeof my.defaultParameters[parameterName] === \"function\" ?\n\t\t\t\t\t\tmy.defaultParameters[parameterName]() :\n\t\t\t\t\t\tmy.defaultParameters[parameterName];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Expand template route and construct URL\n\t\t\tvar aRawUrl = templateRoute.expand(allParameters);\n\t\t\treturn url({rawUrl: aRawUrl});\n\t\t};\n\n\t\t/**\n\t\t * Constructs a link from supplied parameters.\n\t\t *\n\t\t * @param {{}} [parameters={}]\n\t\t * @param {boolean} [excludeCurrentParameters=false]\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tthat.linkToParameters = function(parameters, excludeCurrentParameters) {\n\t\t\treturn my.location.linkToUrl(that.expand({\n\t\t\t\tparameters: parameters,\n\t\t\t\texcludeCurrentParameters: excludeCurrentParameters\n\t\t\t}));\n\t\t};\n\n\t\t/**\n\t\t * Constructs a link from supplied parameters.\n\t\t *\n\t\t * @param {{}} [parameters={}]\n\t\t * @param {boolean} [excludeCurrentParameters=false]\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tthat.setParameters = function(parameters, excludeCurrentParameters) {\n\t\t\tthat.redirectToUrl(that.expand({\n\t\t\t\tparameters: parameters,\n\t\t\t\texcludeCurrentParameters: excludeCurrentParameters\n\t\t\t}));\n\t\t};\n\n\t\t/**\n\t\t * Return current parameters, ether from last match or if no match\n\t\t * from query in current URL.\n\t\t *\n\t\t * @returns {{}} Parameter values with parameter names as keys\n\t\t */\n\t\tthat.getParameters = function() {\n\t\t\tif (!my.lastMatch) {\n\t\t\t\treturn my.location.getUrl().getQuery();\n\t\t\t}\n\n\t\t\treturn my.lastMatch.getParameters();\n\t\t};\n\n\t\t/**\n\t\t * Returns parameter value by name\n\t\t *\n\t\t * @param {string} parameterName\n\t\t * @returns {*}\n\t\t */\n\t\tthat.getParameter = function(parameterName) {\n\t\t\tvar parameters = that.getParameters();\n\t\t\treturn parameters[parameterName];\n\t\t};\n\n\t\tthat.setDefaultParameter = function(parameterName, value) {\n\t\t\tmy.defaultParameters[parameterName] = value;\n\t\t};\n\n\t\t/**\n\t\t * Navigate back to previous location in history. If history is empty\n\t\t * the location will be changed to fallback URL.\n\t\t *\n\t\t * @param {string|url} aFallbackUrl\n\t\t * @returns {string} URL\n\t\t */\n\t\tthat.back = function(aFallbackUrl) {\n\t\t\treturn my.location.back(aFallbackUrl);\n\t\t};\n\n\t\t/**\n\t\t * Return `true` if the history is empty\n\t\t */\n\t\tthat.isHistoryEmpty = function() {\n\t\t\treturn my.location.isHistoryEmpty();\n\t\t};\n\n\t\t/**\n\t\t * Start listening for location changes and automatically\n\t\t * resolve new URLs (including the current)\n\t\t */\n\t\tthat.start = function() {\n\t\t\tmy.location.start();\n\t\t\tmy.resolveUrl(); // resolve current url\n\t\t};\n\n\t\t/**\n\t\t * Stop listening for location changes.\n\t\t */\n\t\tthat.stop = function() {\n\t\t\tmy.location.stop();\n\t\t};\n\n\t\t//\n\t\t// Protected\n\t\t//\n\n\t\t/**\n\t\t * Tries to resolve URL by matching the URL against all routes in\n\t\t * route table. Unless `fallThrough`is set on the matched route router\n\t\t * will stop on first match.\n\t\t *\n\t\t * Last match is also stored as `my.lastMatch`\n\t\t *\n\t\t * @param {url} [aUrl] A URL or current url as default\n\t\t */\n\t\tmy.resolveUrl = function(aUrl) {\n\t\t\tvar currentUrl = aUrl === undefined ? my.location.getUrl() : aUrl;\n\n\t\t\tthat.onResolveUrl.trigger(currentUrl);\n\n\t\t\tvar numMatched = 0;\n\t\t\tmy.routeTable.some(function(candidateRoute) {\n\t\t\t\tvar result = currentUrl.matchRoute(candidateRoute);\n\t\t\t\tif (result.isMatch()) {\n\t\t\t\t\tmy.lastMatch = result;\n\t\t\t\t\tnumMatched++;\n\t\t\t\t\tthat.routeMatched.trigger(result);\n\n\t\t\t\t\tif (candidateRoute.fallThrough === undefined ||\n\t\t\t\t\t\tcandidateRoute.fallThrough === false) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\n\t\t\tif (numMatched === 0) {\n\t\t\t\tthat.routeNotFound.trigger(currentUrl.toString());\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Injects route in route table. Routes are ordered by priority (lower first) with\n\t\t * routes without priority last. Routes with same priority are order in\n\t\t * registration order.\n\t\t *\n\t\t * @param {route} route\n\t\t */\n\t\tmy.addRoute = function(route) {\n\t\t\tvar routeIndex = my.routeTable.length;\n\t\t\tif (route.priority !== undefined) {\n\t\t\t\tdo {\n\t\t\t\t\t--routeIndex;\n\t\t\t\t} while (my.routeTable[routeIndex] &&\n\t\t\t\t(my.routeTable[routeIndex].priority === undefined ||\n\t\t\t\troute.priority < my.routeTable[routeIndex].priority));\n\t\t\t\trouteIndex += 1;\n\t\t\t}\n\t\t\tmy.routeTable.splice(routeIndex, 0, route);\n\t\t};\n\n\t\t//\n\t\t// Private\n\t\t//\n\n\t\t/**\n\t\t * Shallow merge all objects in arguments. Properties in later objects overwrites\n\t\t * properties.\n\t\t *\n\t\t * @returns {{}}\n\t\t */\n\t\tfunction merge() {\n\t\t\tvar objects = Array.prototype.slice.call(arguments);\n\n\t\t\tvar target = {};\n\t\t\tobjects.forEach(function(obj) {\n\t\t\t\tObject.keys(obj).forEach(function(key) {\n\t\t\t\t\ttarget[key] = obj[key];\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn target;\n\t\t}\n\t});\n\n\treturn router;\n});\n\n","define('router',[\n\t\"./router/url\",\n\t\"./router/route\",\n\t\"./router/router\"\n], function(url, route, router) {\n\n\tvar routerSingleton = router();\n\n\treturn {\n\t\turl: url,\n\t\troute: route,\n\t\trouter: router,\n\t\tgetRouter: function() {\n\t\t\treturn routerSingleton;\n\t\t},\n\t\tsetRouter: function(newRouter) {\n\t\t\trouterSingleton = newRouter;\n\t\t}\n\t};\n});\n\n","define('widget',[\n\t\"klassified\",\n\t\"./widget-extensions\",\n\t\"./router\",\n\t\"./events\",\n\t\"./htmlCanvas\",\n\t\"jquery\"\n], function(klassified, widgetExtensions, router, events, htmlCanvas) {\n\n\t/**\n\t * Creates unique ids used by widgets to identify their root div.\n\t */\n\tvar idGenerator = (function() {\n\t\tvar that = {};\n\t\tvar id = 0;\n\n\t\tthat.newId = function() {\n\t\t\tid += 1;\n\t\t\treturn id.toString();\n\t\t};\n\n\t\treturn that;\n\t})();\n\n\t/**\n\t * Helpers for keeping track of the currently rendered widget.\n\t */\n\tvar currentWidget = (function() {\n\t\tvar current;\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\treturn current;\n\t\t\t},\n\t\t\tset: function(widget) {\n\t\t\t\tcurrent = widget;\n\t\t\t}\n\t\t};\n\t})();\n\n\t/**\n\t * Base for all widgets. A widget can keep state in variables, contain logic and\n\t * render itself using `renderOn()`.\n\t *\n\t * @example\n\t *\n\t *        var titleWidget = function(spec) {\n\t *\t\t\tvar that = widget(spec);\n\t *\n\t *\t\t\tvar title = spec.title || \"Hello World\";\n\t *\n\t *\t\t\tthat.renderContentOn = function(html) {\n\t *\t\t\t\thtml.h1(title)\n\t *\t\t\t}\n\t *\n\t *\t\t\treturn that;\n\t *\t\t};\n\t *\n\t *        var helloWorldWidget = titleWidget({title: \"Hello Widget!\"});\n\t *\n\t *        $(document).ready(function() {\n\t *\t\t\thelloWorldWidget.appendTo(\"BODY\");\n\t *\t\t});\n\t *\n\t * Widgets can also be rendered on a HTML canvas (since widget implements `appendToBrush()`). Eg.\n\t *\n\t *        html.div(helloWorldWidget)\n\t *\n\t * It is therefor easy to compose widgets from other widgets.\n\t *\n\t * @virtual\n\t *\n\t * @param {Object} spec\n\t * @param {String} [spec.id] Unique id for widget. Also used for root element when attached/rendered to DOM.\n\t *                           If not provided an ID will automatically be generated and assigned.\n\t * @param {Object} [my]\n\t *\n\t * @returns {widget}\n\t */\n\tvar widget = klassified.object.subclass(function(that, my) {\n\n\t\t/**\n\t\t * Keep track of the rendered subwidgets\n\t\t */\n\t\tvar children;\n\t\tvar id;\n\n\t\tmy.initialize = function(spec) {\n\t\t\tmy.super(spec);\n\t\t\tid = spec.id || idGenerator.newId();\n\t\t\t// When within an update transaction, do not update the widget\n\t\t\tmy.inUpdateTransaction = false;\n\t\t\tchildren = [];\n\t\t};\n\n\t\t/**\n\t\t * Hook evaluated at the end of widget initialization and\n\t\t * before any rendering.\n\t\t */\n\t\tmy.initializeSubwidgets = function(spec) {};\n\n\t\tmy.postInitialize = function(spec) {\n\t\t\tmy.initializeSubwidgets(spec);\n\t\t};\n\n\t\t/** Events for widget */\n\t\tmy.events = events.eventCategory();\n\n\t\tthat.onAttach = my.events.createEvent();\n\t\tthat.onDetach = my.events.createEvent();\n\n\t\t//\n\t\t// Public\n\t\t//\n\n\t\t/**\n\t\t * Returns a unique id for the widget\n\t\t *\n\t\t * @returns {String}\n\t\t */\n\t\tthat.getId = function() {\n\t\t\treturn id;\n\t\t};\n\n\t\tthat.id = that.getId; //TODO: deprecated\n\n\t\t/**\n\t\t * Performance tasks need for freeing/releasing/cleaning-up resources used by widget.\n\t\t *\n\t\t * Should always be executed before a widget is disposed. Especially\n\t\t * if the widget register events to avoid memory leaks.\n\t\t *\n\t\t * Most widgets should override `my.dispose` instead of overriding\n\t\t * this function.\n\t\t *\n\t\t */\n\t\tthat.dispose = function() {\n\t\t\tchildren.forEach(function(child) {\n\t\t\t\tchild.dispose();\n\t\t\t});\n\t\t\tmy.dispose();\n\n\t\t\tmy.events.dispose();\n\t\t};\n\n\t\t/**\n\t\t * Method to be performed when a root widget is detached from the\n\t\t * DOM. The widegt and all its children will call `my.willDetach` in\n\t\t * turn.\n\t\t */\n\t\tthat.willDetach = function() {\n\t\t\tchildren.forEach(function(child) {\n\t\t\t\tchild.willDetach();\n\t\t\t});\n\t\t\tmy.willDetach();\n\t\t\tthat.onDetach.trigger();\n\t\t};\n\n\t\t/**\n\t\t * Renders the widget on a JQuery / DOM\n\t\t *\n\t\t * @example\n\t\t * widget.appendTo(\"BODY\");\n\t\t *\n\t\t * @param aJQuery\n\t\t */\n\t\tthat.appendTo = function(aJQuery) {\n\t\t\tmy.withAttachHooks(function() {\n\t\t\t\trenderBasicOn(htmlCanvas(aJQuery));\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Does the same as appendTo except it first clear the\n\t\t * elements matched by aJQuery\n\t\t *\n\t\t * @param aJQuery\n\t\t */\n\t\tthat.replace = function(aJQuery) {\n\t\t\tmy.withAttachHooks(function() {\n\t\t\t\tvar canvas = htmlCanvas(aJQuery);\n\t\t\t\tcanvas.root.asJQuery().empty();\n\t\t\t\trenderBasicOn(canvas);\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Answers a jQuery that match the root DOM element. By default\n\t\t * by selecting an element that have the same ID as the widget.\n\t\t *\n\t\t * See \"renderOn\"\n\t\t *\n\t\t * @returns {*}\n\t\t */\n\t\tthat.asJQuery = function() {\n\t\t\treturn jQuery(\"#\" + that.getId());\n\t\t};\n\n\t\t/**\n\t\t * Answers true if if widget have rendered content in DOM\n\t\t *\n\t\t * @returns {boolean}\n\t\t */\n\t\tthat.isRendered = function() {\n\t\t\treturn that.asJQuery().length > 0;\n\t\t};\n\n\t\t/**\n\t\t * Implementation for `appendToBrush()` to allow a widget to be\n\t\t * appended to a brush. See \"htmlCanvas\".\n\t\t *\n\t\t * Basically it allows us to do:\n\t\t *        html.div(widget);\n\t\t *\n\t\t * @param aTagBrush\n\t\t */\n\t\tthat.appendToBrush = function(aTagBrush) {\n\t\t\tmy.withAttachHooks(function() {\n\t\t\t\trenderBasicOn(htmlCanvas(aTagBrush.asJQuery()));\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Trigger the `willAttach` event on the receiver and all\n\t\t * rendered subwidgets.\n\t\t */\n\t\tthat.triggerWillAttach = function() {\n\t\t\tmy.willAttach();\n\t\t\tchildren.forEach(function(widget) {\n\t\t\t\twidget.triggerWillAttach();\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Trigger the `didAttach` event on the receiver and all\n\t\t * rendered subwidgets.\n\t\t */\n\t\tthat.triggerDidAttach = function() {\n\t\t\tmy.didAttach();\n\t\t\tchildren.forEach(function(widget) {\n\t\t\t\twidget.triggerDidAttach();\n\t\t\t});\n\t\t\tthat.onAttach.trigger();\n\t\t};\n\n\t\t/**\n\t\t * Evaluate `fn`, calling `willAttach` before and `didAttach` after\n\t\t * the evaluation.\n\t\t */\n\t\tmy.withAttachHooks = function(fn) {\n\t\t\tvar inRendering = inRenderingLoop();\n\t\t\tif (!inRendering) {\n\t\t\t\tthat.triggerWillAttach();\n\t\t\t}\n\t\t\tfn();\n\t\t\tif (!inRendering) {\n\t\t\t\tthat.triggerDidAttach();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Create and expose an event named `name`.\n\t\t */\n\t\tmy.createEvent = function(name) {\n\t\t\tthat[name] = my.events.createEvent();\n\t\t};\n\n\t\t/**\n\t\t * Create and expose one event per string argument.\n\t\t */\n\t\tmy.createEvents = function() {\n\t\t\tvar names = Array.prototype.slice.apply(arguments);\n\t\t\tnames.forEach(my.createEvent);\n\t\t};\n\n\t\t// deprecated, please use the ones below instead\n\t\tthat.on = my.events.on;\n\t\tthat.onceOn = my.events.onceOn;\n\t\tthat.off = my.events.off;\n\n\t\t// Expose events\n\t\tthat.register = my.events.register;\n\t\tthat.registerOnce = my.events.registerOnce;\n\t\tthat.unregister = my.events.unregister;\n\t\tthat.trigger = my.events.trigger;\n\n\t\t//\n\t\t// Protected\n\t\t//\n\n\t\t/**\n\t\t * Exposes the internal ID generator. Generates new unique IDs to be used\n\t\t * for sub-widgets, etc.\n\t\t *\n\t\t * @returns {String}\n\t\t */\n\t\tmy.nextId = function() {\n\t\t\treturn idGenerator.newId();\n\t\t};\n\n\t\t/**\n\t\t * Widget specific dispose.\n\t\t */\n\t\tmy.dispose = function() {};\n\n\t\t// Route / Controller extensions\n\n\t\tmy.router = router.getRouter();\n\n\t\tmy.linkTo = my.router.linkTo;\n\t\tmy.linkToPath = my.router.linkToPath;\n\t\tmy.linkToUrl = my.router.linkToUrl;\n\n\t\tmy.redirectTo = my.router.redirectTo;\n\t\tmy.redirectToPath = my.router.redirectToPath;\n\t\tmy.redirectToUrl = my.router.redirectToUrl;\n\n\t\tmy.redirectToLocationPath = my.router.redirectToLocationPath;\n\n\t\tmy.getParameters = my.router.getParameters;\n\t\tmy.getParameter = my.router.getParameter;\n\t\tmy.setParameters = my.router.setParameters;\n\n\t\t//\n\t\t// Render\n\t\t//\n\n\t\t/**\n\t\t * Private rendering function.    This is the function\n\t\t * internally called each time the widget is rendered, in\n\t\t * `appendTo`, `replace` and `update`.\n\t\t *\n\t\t */\n\t\tfunction renderBasicOn(html) {\n\t\t\tmy.withChildrenRegistration(function() {\n\t\t\t\tthat.renderOn(html);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Main entry point for rendering. For convenience \"renderOn\" will    wrap the content\n\t\t * rendered by \"renderContentOn\" in a root element (renderRootOn) that will be matched\n\t\t * by asJQuery.\n\t\t *\n\t\t * Usually concrete widgets override \"renderContentOn\" to render it content. Widgets\n\t\t * can override \"renderOn\" but must then make sure that it can be matched by \"asJQuery\".\n\t\t *\n\t\t * One way to do that is to make sure to have only one root element and setting the ID of\n\t\t * that element to the ID of the widget.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t *        that.renderOn = function(html) {\n\t\t\t *\t\t\thtml.ul({id: that.getId()}\n\t\t\t *\t\t\t\thtml.li(\"BMW\"),\n\t\t\t *\t\t\t\thtml.li(\"Toyota\")\n\t\t\t *\t\t\t);\n\t\t\t *\t\t};\n\t\t *\n\t\t *\n\t\t * @param html\n\t\t */\n\t\tthat.renderOn = function(html) {\n\t\t\t// Renders widget by wrapping `renderContentOn()` in a root element.\n\t\t\tmy.renderRootOn(html).render(that.renderContentOn);\n\t\t};\n\n\t\tmy.withChildrenRegistration = function(fn) {\n\t\t\tvar parent = currentWidget.get();\n\t\t\tif (parent) {\n\t\t\t\tparent.registerChild(that);\n\t\t\t}\n\t\t\twithCurrentWidget(function() {\n\t\t\t\tchildren = [];\n\t\t\t\tfn();\n\t\t\t}, that);\n\t\t};\n\n\t\tthat.registerChild = function(widget) {\n\t\t\tchildren.push(widget);\n\t\t};\n\n\t\t/**\n\t\t * Renders a wrapper element (by default a \"widgetjs-widget\" tag) and\n\t\t * set the element ID to the ID of the widget so that it can be found by\n\t\t * \"asJQuery\" eg. when we re-render using \"update\".\n\t\t *\n\t\t * @param html\n\t\t * @returns {htmlBrush}\n\t\t */\n\t\tmy.renderRootOn = function(html) {\n\t\t\treturn html.tag(\"widgetjs-widget\").id(id);\n\t\t};\n\n\t\t/**\n\t\t * Overridden in concrete widgets to render widget to canvas/DOM.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t *        that.renderContentOn = function(html) {\n\t\t\t *\t\t\thtml.ul(\n\t\t\t *\t\t\t\thtml.li(\"BMW\"),\n\t\t\t *\t\t\t\thtml.li(\"Toyota\")\n\t\t\t *\t\t\t);\n\t\t\t *\t\t};\n\t\t *\n\t\t * @param {htmlCanvas} html\n\t\t */\n\t\tthat.renderContentOn = function(html) {\n\t\t\treturn my.subclassResponsibility();\n\t\t};\n\n\t\t/**\n\t\t * Hook evaluated before the widget is attached (or reattached due\n\t\t * to an update of rendering) to the DOM.\n\t\t */\n\t\tmy.willAttach = function() {};\n\n\t\t/**\n\t\t * Hook evaluated each time the widget is attached (or\n\t\t * reattached due to an update of rendering) to the DOM.\n\t\t */\n\t\tmy.didAttach = function() {};\n\n\t\t/**\n\t\t * Hook evaluated when a widget is detached from the DOM.\n\t\t */\n\t\tmy.willDetach = function() {};\n\n\t\t/**\n\t\t * Hook evaluated before widget update.\n\t\t */\n\t\tmy.willUpdate = function() {};\n\n\t\t/**\n\t\t * Re-renders the widget and replace it in the DOM\n\t\t */\n\t\tthat.update = function() {\n\t\t\tif (my.inUpdateTransaction || !that.isRendered()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmy.willUpdate();\n\t\t\tmy.withAttachHooks(function() {\n\t\t\t\t// clear content of root\n\t\t\t\tthat.asJQuery().empty();\n\n\t\t\t\t// re-render content on root\n\t\t\t\tvar html = htmlCanvas(that.asJQuery());\n\t\t\t\tmy.withChildrenRegistration(function() {\n\t\t\t\t\tthat.renderContentOn(html);\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tthat.withinTransaction = function(fn, onDone) {\n\t\t\tif (my.inUpdateTransaction) {\n\t\t\t\tfn();\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tmy.inUpdateTransaction = true;\n\t\t\t\t\tfn();\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tmy.inUpdateTransaction = false;\n\t\t\t\t\tif (onDone) {\n\t\t\t\t\t\tonDone();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Evaluate `fn`, ensuring that an update will be\n\t\t * performed after evaluating the function. Nested calls\n\t\t * to `withUpdate` or `update` will result in updating the\n\t\t * widget only once.\n\t\t */\n\t\tthat.withUpdate = function(fn) {\n\t\t\tthat.withinTransaction(fn, that.update);\n\t\t};\n\n\t\tthat.withNoUpdate = function(fn) {\n\t\t\tthat.withinTransaction(fn);\n\t\t};\n\n\t\t// Third party protected extensions** added to `my`.\n\t\t// See widget-extensions.js\n\t\tfor (var extProperty in widgetExtensions) {\n\t\t\tif (widgetExtensions.hasOwnProperty(extProperty)) {\n\t\t\t\tmy[extProperty] = widgetExtensions[extProperty];\n\t\t\t}\n\t\t}\n\n\t\treturn that;\n\t});\n\n\t/**\n\t * Return true if the parent widget is rendering the receiver.\n\t */\n\tfunction inRenderingLoop() {\n\t\treturn !!currentWidget.get();\n\t}\n\n\t/**\n\t * Set `widget` as the current widget while evaluating `fn`.\n\t */\n\tfunction withCurrentWidget(fn, widget) {\n\t\tvar current = currentWidget.get();\n\t\ttry {\n\t\t\tcurrentWidget.set(widget);\n\t\t\tfn();\n\t\t} finally {\n\t\t\tcurrentWidget.set(current);\n\t\t}\n\t}\n\n\treturn widget;\n});\n\n","define('widgetjs',[\n\t\"./htmlCanvas\",\n\t\"./widget\",\n\t\"./widget-extensions\",\n\t\"./router\",\n\t\"./events\"\n], function(htmlCanvas, widget, widgetExtensions, router, events) {\n\treturn {\n\t\thtmlCanvas: htmlCanvas,\n\t\twidget: widget,\n\t\text: widgetExtensions,\n\t\trouter: router,\n\t\tevents: events\n\t};\n});\n\n"]}